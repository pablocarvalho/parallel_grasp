
#include "sig_graph.h"


//---------------------------------------------------------------------------  

void Sigraph::reset() 
{
  str_e  e;

  n_c      = 0;
  n_iso    = 0;   
  n_niso   = 0;
  n_vizig  = 0;
  n_pontes = 0;
  n_add_preproc = 0;

  e.pos = false;
  e.neg = false;
  g.set(e);
  Gp.set(-1);
  Gn.set(-1);
  stat.set(1);
  comp.set(-1);
}

//---------------------------------------------------------------------------  

// calcula a densidade negativa de um grafo
float Sigraph::densidade_neg() 
{
  int    i,j;
  float  cont_pos=0, cont_neg=0;

  for (i=0; i<n-1; ++i)
    if (stat[i]==1)
      {
	for (j=i+1; j<n; ++j)
	  if (stat[j]==1)
	    {
	      if ((g(i,j).pos == true) && (g(i,j).neg == false))
		cont_pos += 1;
	      if ((g(i,j).neg == true) && (g(i,j).pos == false))
		cont_neg += 1;
	    }
      }

  return (cont_neg / cont_pos);
}



//---------------------------------------------------------------------------  


int Sigraph::f_obj(int sol)
{ 
  int    DEPU         = 0;
  
  if (DEPU) std::cout<<std::endl<<"@*********** SOLUCAO **********"<<std::endl;
  if (DEPU) std::cout<<"@ n_iso   = "<<n_iso<<std::endl;
  if (DEPU) std::cout<<"@ n_niso  = "<<n_niso<<std::endl;
  if (DEPU) std::cout<<"@ n_add_p = "<<n_add_preproc<<std::endl;
  if (DEPU) std::cout<<"@ sol     = "<<sol<<std::endl;
  if (DEPU) std::cout<<"@ TOTAL   = "<<(sol + n_iso + n_niso + n_add_preproc)<<std::endl<<std::endl;

  return (sol + n_iso + n_niso + n_add_preproc);
}

//---------------------------------------------------------------------------  

// numero de vertices ativos do grafo
int Sigraph::num_n()
{ 
  int    i,cont=0;
  
  for (i=0; i<n; ++i)
    if (stat[i]==1)
      cont++;

  return cont;
}

// numero de arestas ativas do grafo (entre vertices ativos)
int Sigraph::num_m()
{ 
  int    i,j,cont=0;
  
  for (i=0; i<n-1; ++i)
    if (stat[i]==1)
      for (j=i+1; j<n; ++j)
	if (stat[j]==1)
	  if ((g(i,j).pos == true) || (g(i,j).neg == true))
	    cont++;

  return cont;
}


// Cria grafo a partir de uma matriz preprocessada
void Sigraph::ini(Matriz<double> &A, int nrow, int ncol, Array<bool> &r, int count)
{ 
  int    i,j, k, ip, in;
  str_e  e;
  bool   e1, e2;
  int    DEPU         = 0;

  if (DEPU) std::cout<<"construindo sg, count = "<<count<<std::endl;

  /* aloca */
  n        = count;
  n_c      = 0;
  n_iso    = 0;   
  n_niso   = 0;
  n_vizig  = 0;
  n_pontes = 0;
  n_add_preproc = 0;

  g.aloca(n,n);
  Gp.aloca(n,n);
  Gn.aloca(n,n);
  map.aloca(n);
  stat.aloca(n);
  comp.aloca(n);
  vet1.aloca(n);
  vet2.aloca(n);
  vet3.aloca(n);
  vet4.aloca(n);

  /* atribui */
  e.pos = false;
  e.neg = false;
  g.set(e);
  Gp.set(-1);
  Gn.set(-1);
  stat.set(1);
  comp.set(-1);

  if (DEPU) std::cout<<" constroi mapa"<<std::endl;
  for (j=0, i=1; i<nrow; ++i)
    if (r[i])
      {
	map[j] = i;
	j++;
      }
  if (DEPU) map.imprime();

  /*insere arestas (i,j) em g */
  if (DEPU) std::cout<<" insere arestas"<<std::endl;
  for (i=0; i<n-1; ++i)
    {
      for (j=i+1; j<n; ++j)
	{
	  e1 = e2 = false;
	  for (k=0; k<ncol; k++)
	    {
	      if ((e1 == false) && (A(map[i], k) == -A(map[j], k)) && (A(map[i], k) != 0))
		{
		  g(i,j).pos = true;
		  g(j,i).pos = true; 
		  e1         = true;
		  if (DEPU) std::cout<<"     + ("<<map[i]<<","<<map[j]<<") k = "<<k<<std::endl;

		}

	      if ((e2 == false) && ((A(map[i], k) == A(map[j], k)) && (A(map[i], k) != 0)))
		{
		  g(i,j).neg = true;
		  g(j,i).neg = true;
		  e2         = true;
		  if (DEPU) std::cout<<"     - ("<<map[i]<<","<<map[j]<<") k = "<<k<<std::endl;
		}

	      if ((e1 == true) && (e2 == true))
		break;
	    }
	}
    }

  /* Constroi Gp e Gn */
  if (DEPU) std::cout<<" constroi Gp e Gn"<<std::endl;
  for (i=0; i<n; ++i)
    {
      ip = in = 0;
      for (j=0; j<n; ++j)
	{
	  if (g(i,j).pos) Gp(i, ip++) = j;
	  if (g(i,j).neg) Gn(i, in++) = j;
	}
    }
  if (DEPU) Gp.imprime();
  if (DEPU) Gn.imprime();
} 


//-------------------------------------------------------------------------------

// gera grafo a partir de um arquivo .G
float Sigraph::ini(std::ifstream &fin) 
{
  int    i, j, n_are, a1, a2, at, ip, in;
  str_e  e;
  int    DEPU         = 0;
  float  cont_pos=0, cont_neg=0;
  if (DEPU) std::cout<<"construindo sg, "<<std::endl;

  /* aloca */
  fin>>n;
  fin>>n_are;
  n_c      = 0;
  n_iso    = 0;   
  n_niso   = 0;
  n_vizig  = 0;
  n_pontes = 0;
  n_add_preproc = 0;
  /* aloca */
  g.aloca(n,n);
  Gp.aloca(n,n);
  Gn.aloca(n,n);
  map.aloca(n);
  stat.aloca(n);
  comp.aloca(n);
  vet1.aloca(n);
  vet2.aloca(n);
  vet3.aloca(n);
  vet4.aloca(n);

  /* atribui */
  e.pos = false;
  e.neg = false;
  g.set(e);
  Gp.set(-1);
  Gn.set(-1);
  stat.set(1);
  comp.set(-1);

  /*insere arestas (i,j) em g */
  if (DEPU) std::cout<<" insere arestas"<<std::endl;
  for (i=1; i<=n_are; ++i)
    {
      fin>>a1;
      fin>>a2;
      fin>>at;

      /* + */
      if ((at == 1) || (at == 2))
	{
	  g(a1,a2).pos = true;
	  g(a2,a1).pos = true; 

	  if (at != 2) cont_pos += 1;
	}

      /* - */
      if ((at == -1) || (at == 2))
	{
	  g(a1,a2).neg = true;
	  g(a2,a1).neg = true; 

	  if (at != 2) cont_neg += 1;
	}
    }

  /* Constroi Gp e Gn */
  if (DEPU) std::cout<<" constroi Gp e Gn"<<std::endl;
  for (i=0; i<n; ++i)
    {
      ip = in = 0;
      for (j=0; j<n; ++j)
	{
	  if (g(i,j).pos) Gp(i, ip++) = j;
	  if (g(i,j).neg) Gn(i, in++) = j;
	}
    }
  if (DEPU) Gp.imprime();
  if (DEPU) Gn.imprime();

  return (cont_neg / cont_pos);
}


//-------------------------------------------------------------------------------


/* gera copia de uma componente do grafo */
void Sigraph::ini(Sigraph * _sg, int id_comp)
{ 
  int    i,j, ip, in;
  str_e  e;
  int    DEPU         = 1;

  if (DEPU) std::cout<<"construindo sg, componente = "<<id_comp<<std::endl;

  //determina n
  for (n=0, i=0; i<_sg->n; i++)
    if (_sg->comp[i] == id_comp)
      n++;
  if (DEPU) std::cout<<" n = "<<n<<std::endl;
  
  /* aloca */
  n_c      = 0;
  n_iso    = 0;   
  n_niso   = 0;
  n_vizig  = 0;
  n_pontes = 0;
  n_add_preproc = 0;

  g.aloca(n,n);
  Gp.aloca(n,n);
  Gn.aloca(n,n);
  map.aloca(n);
  stat.aloca(n);
  comp.aloca(n);
  vet1.aloca(n);
  vet2.aloca(n);
  vet3.aloca(n);
  vet4.aloca(n);

  /* atribui */
  e.pos = false;
  e.neg = false;
  g.set(e);
  Gp.set(-1);
  Gn.set(-1);
  stat.set(1);
  comp.set(-1);

  if (DEPU) std::cout<<" constroi mapa"<<std::endl;
  for (j=0, i=0; i<_sg->n; i++)
    if (_sg->comp[i] == id_comp)
      {
	map[j] = i;
	j++;
      }
  if (DEPU) map.imprime();

  /*insere arestas (i,j) em g */
  if (DEPU) std::cout<<" insere arestas"<<std::endl;
  for (i=0; i<n-1; ++i)
    for (j=i+1; j<n; ++j)
      {
	g(i,j).pos = _sg->g(map[i],map[j]).pos;
	g(j,i).pos = _sg->g(map[i],map[j]).pos;
	
	g(i,j).neg = _sg->g(map[i],map[j]).neg;
	g(j,i).neg = _sg->g(map[i],map[j]).neg;
      }

  /* Constroi Gp e Gn */
  if (DEPU) std::cout<<" constroi Gp e Gn"<<std::endl;
  for (i=0; i<n; ++i)
    {
      ip = in = 0;
      for (j=0; j<n; ++j)
	{
	  if (g(i,j).pos) Gp(i, ip++) = j;
	  if (g(i,j).neg) Gn(i, in++) = j;
	}
    }
  if (DEPU) Gp.imprime();
  if (DEPU) Gn.imprime();
} 





//----------------------------------------------------------------------------------------


// cria grafo artificial pré-estabelecido 
void Sigraph::ini_dep()
{ 
  int    i,j, ip, in;
  str_e  e;
  int    DEPU         = 1;

  if (DEPU) std::cout<<"construindo sg DEPURACAO"<<std::endl;

  /* aloca */
  n        = 21;
  n_c      = 0;
  n_iso    = 0;   
  n_niso   = 0;
  n_vizig  = 0;
  n_pontes = 0;
  n_add_preproc = 0;

  g.aloca(n,n);
  Gp.aloca(n,n);
  Gn.aloca(n,n);
  map.aloca(n);
  stat.aloca(n);
  comp.aloca(n);
  vet1.aloca(n);
  vet2.aloca(n);
  vet3.aloca(n);
  vet4.aloca(n);

  /* atribui */
  e.pos = false;
  e.neg = false;
  g.set(e);
  Gp.set(-1);
  Gn.set(-1);
  stat.set(1);
  comp.set(-1);

  if (DEPU) std::cout<<" constroi mapa"<<std::endl;
  for (i=0; i<n; ++i)
    map[i] = i;
  if (DEPU) map.imprime();

  /*insere arestas (i,j) em g */
  if (DEPU) std::cout<<" insere arestas"<<std::endl;

  g(0,1).neg = true;
  g(1,0).neg = true;
  g(1,2).neg = true;
  g(2,1).neg = true;
  g(3,2).neg = true;
  g(2,3).neg = true;
  g(3,4).neg = true;
  g(4,3).neg = true;
  g(0,9).neg = true;
  g(9,0).neg = true;
  g(0,1).neg = true;
  g(1,0).neg = true;
  g(1,9).neg = true;
  g(9,1).neg = true;
  g(0,8).neg = true;
  g(8,0).neg = true;
  g(7,8).neg = true;
  g(8,7).neg = true;
  g(0,7).neg = true;
  g(7,0).neg = true;
  g(6,7).neg = true;
  g(7,6).neg = true;
  g(7,5).neg = true;
  g(5,7).neg = true;
  g(5,6).neg = true;
  g(6,5).neg = true;
  g(1,3).neg = true;
  g(3,1).neg = true;
  g(1,2).neg = true;
  g(2,1).neg = true;
  g(2,3).neg = true;
  g(3,2).neg = true;
  g(1,4).neg = true;
  g(4,1).neg = true;
  g(2,4).neg = true;
  g(4,2).neg = true;
  g(3,4).neg = true;
  g(4,3).neg = true;
  g(1,7).neg = true;
  g(7,1).neg = true;
  g(5,10).neg = true;
  g(10,5).neg = true;
  g(10,11).neg = true;
  g(11,10).neg = true;
  g(12,11).neg = true;
  g(11,12).neg = true;
  g(10,12).neg = true;
  g(12,10).neg = true;
  g(8,13).neg = true;
  g(13,8).neg = true;
  g(14,13).neg = true;
  g(13,14).neg = true;
  g(11,15).neg = true;
  g(15,11).neg = true;
  g(15,16).neg = true;
  g(16,15).neg = true;
  g(16,17).neg = true;
  g(17,16).neg = true;
  g(15,17).neg = true;
  g(17,15).neg = true;
  g(16,18).neg = true;
  g(18,16).neg = true;
  g(19,20).neg = true;
  g(20,19).neg = true;
  g(4,19).neg = true;
  g(19,4).neg = true;
  g(20,4).neg = true;
  g(4,20).neg = true;

  g(19,20).pos = true;
  g(20,19).pos = true;
  g(20,3).pos = true;
  g(3,20).pos = true;
  g(3,19).pos = true;
  g(19,3).pos = true;

  /* Constroi Gp e Gn */
  if (DEPU) std::cout<<" constroi Gp e Gn"<<std::endl;
  for (i=0; i<n; ++i)
    {
      ip = in = 0;
      for (j=0; j<n; ++j)
	{
	  if (g(i,j).pos) Gp(i, ip++) = j;
	  if (g(i,j).neg) Gn(i, in++) = j;
	}
    }
  if (DEPU) Gp.imprime();
  if (DEPU) Gn.imprime();
} 


//----------------------------------------------------------------------------

// Cria grafo vazio de tamanho n
void Sigraph::ini(int nn)
{ 
  str_e  e;
  int    DEPU         = 0;

  /* aloca */
  n        = nn;
  n_c      = 0;
  n_iso    = 0;   
  n_niso   = 0;
  n_vizig  = 0;
  n_pontes = 0;
  n_add_preproc = 0;

  g.aloca(n,n);
  Gp.aloca(n,n);
  Gn.aloca(n,n);
  map.aloca(n);
  stat.aloca(n);
  comp.aloca(n);
  vet1.aloca(n);
  vet2.aloca(n);
  vet3.aloca(n);
  vet4.aloca(n);

  /* atribui */
  e.pos = false;
  e.neg = false;
  g.set(e);
  Gp.set(-1);
  Gn.set(-1);
  stat.set(1);
  comp.set(-1);

  if (DEPU) Gp.imprime();
  if (DEPU) Gn.imprime();
} 


//----------------------------------------------------------------------------


void Sigraph::fini()
{ 
  /* desaloca */
  g.desaloca();
  Gp.desaloca();
  Gn.desaloca();
  map.desaloca();
  stat.desaloca();
  comp.desaloca();
} 


//---------------------------------------------------------------------------  

bool Sigraph::preproc_vert_iso(int tipo)
{ 
  int     i, j, k, l, ct1, ct2, ct3;
  bool    retira, continua, saida, vai, achou;

  int    DEPU         = 1;
  int    at1, at2, at3;

  at1 = at2 = at3 = 0;
  if (tipo == -1)
    {
      at1 = 1;
      at2 = 1;
      at3 = 1;
    }
  if (tipo == 1) at1 = 1;
  if (tipo == 2) at2 = 1;
  if (tipo == 3) at3 = 1;

  if (DEPU) std::cout<<" preproc"<<std::endl;
  
  // inicializacao 
  ct1 = ct2 = ct3 = 0;
  continua = true;
  saida    = false;

  while (continua)
    {
      continua = false;

      // (1) vertices isolados
      if (at1 == 1)
	{
	  for (i=0; i<n; ++i)
	    if (stat[i]==1)
	      {
		for (j=0; Gp(i,j)!=-1; ++j) // tem vizinho positivo ?
		  if (stat[Gp(i,j)]==1)
		    break;
		
		if (Gp(i,j) == -1)
		  {
		    for (j=0; Gn(i,j)!=-1; ++j) // tem vizinho negativo ?
		      if (stat[Gn(i,j)]==1)
			break;
		    
		    if (Gn(i,j) == -1)
		      {
			stat[i] = 2;
			ct1++;
			n_iso++;
			continua = true;
			saida    = true;
			if (DEPU) std::cout<<" vert. "<<i<<" isolado"<<std::endl;
		      }
		  }
	      }
	}

      // (2) vertices negativamente isolados onde os vertices de sua vizinhança formam uma clique positiva
      if (at2 == 1)
	{
	  for (i=0; i<n; ++i)
	    if (stat[i]==1)
	      {
		for (j=0; Gn(i,j)!=-1; ++j) // tem vizinho negativo ?
		  if (stat[Gn(i,j)]==1)
		    break;
		
		if (Gn(i,j) == -1)
		  {
		    retira = true; // tem vizinhos com arestas negativas entre eles
		    for (j=0; (Gp(i,j)!=-1) && retira; j++)
		      if (stat[Gp(i,j)]==1)
			for (k=j+1; (Gp(i,k)!=-1) && retira; k++)
			  if (stat[Gp(i,k)]==1)
			    if (g(Gp(i,j),Gp(i,k)).neg == true) retira = false;
		    
		    if (retira) // vizinhança formam uma clique positiva
		      {
			for (j=0; (Gp(i,j)!=-1) && retira; j++)
			  if (stat[Gp(i,j)]==1)
			    for (k=j+1; (Gp(i,k)!=-1) && retira; k++)
			      if (stat[Gp(i,k)]==1)
				if (g(Gp(i,j),Gp(i,k)).pos == false) retira = false;
		      }

		    if (retira)
		      {
			stat[i] = 3;
			ct2++;
			n_niso++;
			continua = true;
			saida    = true;
			if (DEPU) std::cout<<" vert. neg. "<<i<<" isolado"<<std::endl;

			/*if (n_niso > 10)
			  {
			    continua = false;
			    saida    = false;
			    break;
			    }*/
		      }
		  }
	      }
	}

      // (5.a) Vertices "i" e "j" onde N+(i) = N+(j) e  N-(i) = N-(j) e (i,j) \in E+ e (i,j) \in E-
      if (at3 == 1)
	{
	  for (i=0; i<n-1; ++i)
	    if (stat[i]==1)
	      {
		for (j=i+1; j<n; ++j)
		  if (stat[j]==1)
		    {
		      if ((g(i,j).pos == true) && (g(i,j).neg == true))
			{
			  vai=true;
			  //if (DEPU) std::cout<<" i = "<<i<<" j = "<<j<<std::endl;
			  
			  // checa vizinhanca positiva  --->
			  for (k=0; Gp(i,k)!=-1 && vai; ++k) 
			    if ((stat[Gp(i,k)]==1) && (Gp(i,k) != j))
			      {
				//if (DEPU) std::cout<<"   testa = "<<Gp(i,k)<<std::endl;
				for (achou=false, l=0; Gp(j,l)!=-1 && vai; ++l) 
				  if ((stat[Gp(j,l)]==1) && (Gp(j,l) == Gp(i,k)))
				    {
				      achou = true;
				      break;
				    }
				
				if (!achou)
				  vai = false;
			      }
			  
			  // checa vizinhanca positiva  <---
			  if (vai)
			    {
			      //if (DEPU) std::cout<<" 1"<<j<<std::endl;
			      for (k=0; Gp(j,k)!=-1 && vai; ++k) 
				if ((stat[Gp(j,k)]==1) && (Gp(j,k) != i))
				  {
				    for (achou=false, l=0; Gp(i,l)!=-1 && vai; ++l) 
				      if ((stat[Gp(i,l)]==1) && (Gp(i,l) == Gp(j,k)))
					{
					  achou = true;
					  break;
					}
				    
				    if (!achou)
				      vai = false;
				  }
			      
			      if (vai)
				{
				  //if (DEPU) std::cout<<" 2"<<j<<std::endl;
				  // checa vizinhanca negativa  --->
				  for (k=0; Gn(i,k)!=-1 && vai; ++k) 
				    if ((stat[Gn(i,k)]==1) && (Gn(i,k) != j))
				      {
					for (achou=false, l=0; Gn(j,l)!=-1 && vai; ++l) 
					  if ((stat[Gn(j,l)]==1) && (Gn(j,l) == Gn(i,k)))
					    {
					      achou = true;
					      break;
					    }
					
					if (!achou)
					  vai = false;
				      }
				  
				  // checa vizinhanca negativa  <---
				  if (vai)
				    {
				      //if (DEPU) std::cout<<" 3"<<j<<std::endl;
				      for (k=0; Gn(j,k)!=-1 && vai; ++k) 
					if ((stat[Gn(j,k)]==1) && (Gn(j,k) != i))
					  {
					    for (achou=false, l=0; Gn(i,l)!=-1 && vai; ++l) 
					      if ((stat[Gn(i,l)]==1) && (Gn(i,l) == Gn(j,k)))
						{
						  achou = true;
						  break;
						}
					    
					    if (!achou)
					      vai = false;
					  }
				    }
				}
			    }

			  if (vai)
			    {
			      stat[j] = 5;
			      ct3++;
			      n_vizig++;
			      continua = true;
			      saida    = true;
			      if (DEPU) std::cout<<" vert. retirado 5a = "<<j<<std::endl;
			    } 
			}
		  
		    }
	      }   
	}
      
    } // while (continua)

  // identifica novas componentes
  encontra_componentes();

  //if (DEPU) stat.imprime();
  if (DEPU) std::cout<<" Vertices isolados      = "<<ct1<<std::endl;
  if (DEPU) std::cout<<" Vertices neg. isolados = "<<ct2<<std::endl;
  if (DEPU) std::cout<<" Vertices 5a retirados  = "<<ct3<<std::endl;

  return saida;
}


//---------------------------------------------------------------------------  

void Sigraph::encontra_componentes()
{
  int               i, j, a1, a2, p_a1, p_a2, id_comp, componente, count;
  Adt               _adt(n);

  int    DEPU         = 0;

  // preenche conjunto de vertices 
  //if (DEPU) std::cout<<"preenche vetores. n = "<<n<<std::endl;
  for (i=0; i<n; ++i)
    if (stat[i]==1)
      {
	//if (DEPU) std::cout<<i<<", ";
	_adt.novo_conjunto(i);
      }
  //if (DEPU) std::cout<<std::endl;

  // percorre arestas determinando as componentes
  //if (DEPU) std::cout<<"percorre arestas"<<std::endl;
  for (i=0; i<n; ++i)
    if (stat[i]==1)
      {
	//if (DEPU) std::cout<<"  vert "<<i<<std::endl;

	//if (DEPU) std::cout<<"    vizinhanca negativa"<<std::endl;
	// vizinhanca negativa
	for (j=0; Gn(i,j)!=-1; ++j) 
	  if (stat[Gn(i,j)]==1)
	    {
	      a1 = i;
	      a2 = Gn(i,j);
	      //if (DEPU) std::cout<<"      a1 = "<<a1<<" a2 = "<<a2<<std::endl;

	      p_a1 = _adt.pai_top(a1);
	      p_a2 = _adt.pai_top(a2);

	      if (p_a1 != p_a2)
		_adt.uniao(p_a1, p_a2);
	    }

	//if (DEPU) std::cout<<"    vizinhanca positiva"<<std::endl;
	// vizinhanca positiva
	for (j=0; Gp(i,j)!=-1; ++j) 
	  if (stat[Gp(i,j)]==1)
	    {
	      a1 = i;
	      a2 = Gp(i,j);

	      p_a1 = _adt.pai_top(a1);
	      p_a2 = _adt.pai_top(a2);

	      if (p_a1 != p_a2)
		_adt.uniao(p_a1, p_a2);
	    }

      } // for (i=0; i<n; ++i)

  //if (DEPU) std::cout<<"preenche componentes "<<std::endl;
  // preenche componentes
  comp.set(-1);
  for(i=0; i<n; ++i)
    if (_adt.get_pai(i) != -1)
      comp[i] = _adt.pai_top(i) + n;
    
  //if (DEPU) std::cout<<"IMPRIME COMPONENTES"<<std::endl;
  //if (DEPU) comp.imprime();

  //reducao dos indices das componentes 
  for(id_comp=0, i=0; i<n; ++i)
    {
      componente = comp[i];
      if (componente >= n)
	{
	  for(j=i; j<n; ++j)
	    if (componente == comp[j])
	      comp[j] = id_comp;

	  id_comp++;
	}
    }
  n_c = id_comp;

  if (DEPU) std::cout<<"imprime componentes"<<std::endl;
  if (DEPU) comp.imprime();
  if (DEPU) std::cout<<"numero de componentes = "<<n_c<<std::endl;
  for (i=0; i<n_c; i++)
    {
      for (count=0, j=0; j<n; j++)
	if ((stat[j] == 1) && (comp[j] == i))
	  {
	    if (DEPU) std::cout<<j<<", ";
	    count++;
	  }
      if (DEPU) std::cout<<std::endl<<"   comp "<<i<<") n = "<<count<<std::endl;
    }
}


//---------------------------------------------------------------

bool  Sigraph::preproc_DFS_ponte()
{
  int           i_comp, i, j, w, raiz=-1, cont, last_j;
  bool          art, saida;
  Array<int>    prede;
  Array<int>    dista;
  Array<int>    cores;
  Array<int>    lowpt;
  Array<int>    artic;

  int    DEPU         = 1;

  // aloca 
  prede.aloca(n);
  dista.aloca(n);
  cores.aloca(n);
  lowpt.aloca(n);
  artic.aloca(n);     

  saida = false;

  for (i_comp=0; i_comp<n_c; i_comp++)
    {
      //if (DEPU) std::cout<<"------- DFS_ponte comp = "<<i_comp<<std::endl;
  
      for(j=0, i=0; i<n; ++i)
	{
	  if (comp[i] == i_comp)
	    {
	      raiz = i;
	      j++;
	    }
	}
      //if (DEPU) std::cout<<"num_vert_comp = "<<j<<" raiz = "<<raiz<<" n = "<<n<<std::endl;
  
      // componente com apenas um vertice, nao tem pontes
      if (j <= 1)
	continue;
      
      // atribui
      prede.set(-1);      // predecessor
      dista.set(0);       // altura
      cores.set(0);       // 0 - BRANCO (nao entrou na pilha) , 1 - CINZA (na pilha), 2 - PRETO (ja saiu da pilha)
      artic.set(0);       // vetor de articulacoes  

      // inicializacao 
      prede[raiz] = raiz;
      lowpt[raiz] = raiz;
      for (i=0; i<n; i++)
	lowpt[i] = i;

      // Busca em profundidade recursiva 
      DFS_rec(raiz, prede, dista, cores,  lowpt);
      
      //prede.imprime();
      //lowpt.imprime();
      //dista.imprime();
      
      //identifica articulacoes
      for (i=0; i<n; ++i)
	if ((comp[i] == i_comp) && (stat[i]==1) && (i != raiz))
	  {
	    for (art=false, j=0; j<n; ++j) 
	      if ((comp[j] == i_comp) && (prede[j]==i) && (j != i))
		{
		  w = j;
		  if ((lowpt[w] == i) || (lowpt[w] == w))
		    {
		      art = true;
		      break;
		    }
		}
	    
	    if (art)
	      {
		artic[i] = 1; 
		//if (DEPU) std::cout<<"  art = "<<i<<std::endl;
	      }
	  }
      
      // raiz articulacao ?
      for (w=0, j=0; j<n; ++j) 
	if ((comp[j] == i_comp))
	  if ((prede[j]==raiz) && (j != raiz))
	    w++;
      
      if (w > 1)
	{
	  artic[raiz] = 1; 
	  //if (DEPU) std::cout<<"  raiz art = "<<raiz<<std::endl;
	}
      
      // encontra pontes triviais ( arestas conectando folhas )
      for (i=0; i<n; ++i)
	if (comp[i] == i_comp)
	  if (stat[i]==1)
	    {
	      for (last_j=-1, cont=0, j=0; j<n; ++j)
		if (comp[j] == i_comp)
		  if (i != j)
		    if ((g(i,j).pos == true) || (g(i,j).neg == true))
		      {
			cont ++;
			last_j = j;
		      }
	      
	      if ((cont == 1) && (((g(i,last_j).pos == true) && (g(i,last_j).neg == false)) || ((g(i,last_j).pos == false) && (g(i,last_j).neg == true))))
		{
		  stat[i] = 4;
		  if (DEPU) std::cout<<"Vert isolado ponte = "<<i<<std::endl;
		  
		  /*if ((g(i,last_j).pos == true) && (g(i,last_j).neg == true))
		    {
		      std::cout<<"FUDEU, regra 4 em areta +-"<<std::endl;
		      abort();
		      }*/

		  /* retira aresta da estrutura */
		  delete_edge(i, last_j, 3);
		  saida = true;

		  n_iso++;
		  n_pontes++;
		}
	    }
      
      // encontra pontes nao triviais ( aresta entre 2 articulacoes )
      for (i=0; i<n-1; ++i)
	if ((comp[i] == i_comp) && (stat[i]==1) && (artic[i]==1))
	  for (j=i+1; j<n; ++j)
	    if ((comp[j] == i_comp) && (stat[j]==1) && (artic[j]==1))
	      if (((g(i,j).pos == true) && (g(i,j).neg == false)) || ((g(i,j).pos == false) && (g(i,j).neg == true)))
		{
		  // inicializacao 
		  prede.set(-1); 
		  dista.set(0);
		  cores.set(0); 
		  prede[i] = i;
		  lowpt[i] = i;
		  for (w=0; w<n; w++)
		    lowpt[w] = w;
		  
		  // Busca em profundidade de "i" para chegar a "j" sem passar pela aresta (i,j)
		  if (DFS_reach_uv(i, i, j, prede, dista, cores, lowpt) == false)
		    {
		      if (DEPU) std::cout<<"tira Ponte = "<<i<<","<<j<<std::endl;
		      
		      /*if ((g(i,j).pos == true) && (g(i,j).neg == true))
			{
			  std::cout<<"FUDEU, regra 4 em areta +-"<<std::endl;
			  abort();
			  }*/

		      /* retira aresta da estrutura */
		      delete_edge(i, j, 3);
		      saida = true;
		      n_pontes++;
		    }
		}

    }/*  for (i_comp=0; i_comp<n_c; i_comp++) */

  // libera
  prede.desaloca();
  dista.desaloca();
  cores.desaloca();
  lowpt.desaloca();
  artic.desaloca();

  // encontra componentes
  if (saida)
    {
      encontra_componentes();
      return true;
    }
  else
    return false;
}


//------------------------------------------------------------------------------------------------------------


/* DFS recursiva */
void Sigraph::DFS_rec(int w, Array<int> &prede, Array<int> &dista, Array<int> &cores,  Array<int>  &lowpt)
{
  int    i, v, x;
  int    DEPU         = 0;
  
  if (DEPU) std::cout<<"       **  DFS_rec **"<<std::endl;

  // marca como na pilha
  cores[w] = 1;

  /* para todo vizinho negativo faca */
  for (i=0; Gn(w,i)!=-1; ++i) 
    if (stat[Gn(w,i)]==1)
      {
	v = Gn(w,i);
	
	if ((cores[v] == 0) && (prede[v] == -1))
	    {
	      prede[v]    = w;
	      dista[v]    = dista[w] + 1;
	      if (DEPU) std::cout<<"         arco arv"<<w<<","<<v<<std::endl;

	      DFS_rec(v, prede, dista, cores,  lowpt);
	    }
	else
	  // aresta de retorno
	  if ((cores[v] == 1) && (v != prede[w]))
	    {
	      //if (DEPU) std::cout<<"         arco ret"<<w<<","<<v<<std::endl;
	      if (dista[lowpt[w]] > dista[v])
		{
		  lowpt[w] = v;
		  
		  //atualiza os outros lowpt anteriores a v
		  x = prede[w];
		  while (x != v)
		    {
		      if (dista[lowpt[x]] > dista[v])
			lowpt[x] = v;
		      x = prede[x];
		    }
		  //if (DEPU) lowpt.imprime();
		}
	    }
      }

  /* para todo vizinho positiva faca */
  for (i=0; Gp(w,i)!=-1; ++i) 
    if (stat[Gp(w,i)]==1)
      {
	v = Gp(w,i);
	
	if ((cores[v] == 0) && (prede[v] == -1))
	  {
	    prede[v]    = w;
	    dista[v]    = dista[w] + 1;
	    if (DEPU) std::cout<<"         arco arv"<<w<<","<<v<<std::endl;

	    DFS_rec(v, prede, dista, cores,  lowpt);
	  }
	else
	  // aresta de retorno
	  if ((cores[v] == 1) && (v != prede[w]))
	    {
	      //if (DEPU) std::cout<<"         arco ret"<<w<<","<<v<<std::endl;
	      if (dista[lowpt[w]] > dista[v])
		{
		  lowpt[w] = v;
		  
		  //atualiza os outros lowpt anteriores a v
		  x = prede[w];
		  while (x != v)
		    {
		      if (dista[lowpt[x]] > dista[v])
			lowpt[x] = v;
		      x = prede[x];
		    }
		  //if (DEPU) lowpt.imprime();
		}
	    }
      }

  // marca como visitado
  cores[w] = 2;

}


/* Tenta a partir de W chegar em FIM, sem passar pela aresta (INI,FIM) */
bool Sigraph::DFS_reach_uv(int w, int ini, int fim, Array<int> &prede, Array<int> &dista, Array<int> &cores, Array<int>  &lowpt)
{
  int    i, v, x;
  int    DEPU         = 0;


  // marca como na pilha
  cores[w] = 1;

  /* para todo vizinho negativo faca */
  for (i=0; Gn(w,i)!=-1; ++i) 
    if ((stat[Gn(w,i)]==1))
      if ((w != ini) || (Gn(w,i) != fim))
	{
	  v = Gn(w,i);
	  
	  if (v == fim)
	    {
	      if (DEPU) std::cout<<"           alcancou w = "<<w<<" v = "<<v<<std::endl;
	      return true;
	    }
	  
	  if ((cores[v] == 0) && (prede[v] == -1))
	    {
	      prede[v]    = w;
	      dista[v]    = dista[w] + 1;
	      if (DEPU) std::cout<<"         arco arv"<<w<<","<<v<<std::endl;
	      
	      if (DFS_reach_uv(v, ini, fim, prede, dista, cores, lowpt) == true)
		return true;
	    }
	  else
	    // aresta de retorno
	    if ((cores[v] == 1) && (v != prede[w]))
	      {
		//if (DEPU) std::cout<<"         arco ret"<<w<<","<<v<<std::endl;
		if (dista[lowpt[w]] > dista[v])
		  {
		    lowpt[w] = v;
		    
		    //atualiza os outros lowpt anteriores a v
		    x = prede[w];
		    while (x != v)
		      {
			if (dista[lowpt[x]] > dista[v])
			  lowpt[x] = v;
			x = prede[x];
		      }
		    //if (DEPU) lowpt.imprime();
		  }
	      }
	}

  /* para todo vizinho positiva faca */
  for (i=0; Gp(w,i)!=-1; ++i) 
    if (stat[Gp(w,i)]==1)
      if ((w != ini) || (Gn(w,i) != fim))
	{
	  v = Gp(w,i);
	  
	  if (v == fim)
	    {
	      if (DEPU) std::cout<<"           alcancou w = "<<w<<" v = "<<v<<std::endl;
	      return true;
	    }
	  
	  if ((cores[v] == 0) && (prede[v] == -1))
	    {
	      prede[v]    = w;
	      dista[v]    = dista[w] + 1;
	      if (DEPU) std::cout<<"         arco arv"<<w<<","<<v<<std::endl;
	      
	      if (DFS_reach_uv(v, ini, fim, prede, dista, cores, lowpt) == true)
		return true;
	    }
	  else
	    // aresta de retorno
	    if ((cores[v] == 1) && (v != prede[w]))
	      {
		//if (DEPU) std::cout<<"         arco ret"<<w<<","<<v<<std::endl;
		if (dista[lowpt[w]] > dista[v])
		  {
		    lowpt[w] = v;
		    
		    //atualiza os outros lowpt anteriores a v
		    x = prede[w];
		    while (x != v)
		      {
			if (dista[lowpt[x]] > dista[v])
			  lowpt[x] = v;
			x = prede[x];
		      }
		    //if (DEPU) lowpt.imprime();
		  }
	      }
	}
  
  // marca como visitado
  cores[w] = 2;

  return false;

}


//------------------------------------------------------------------------------------

// Considera apenas os vertices do grafo com STATUS = flag

int Sigraph::solve_dumb(int flag)
{
  int     i_comp, b_sol, b_sol_t;
  int     DEPU         = 0;

  if (DEPU) std::cout<<"--- solve_dumb"<<" flag = "<<flag<<std::endl;
  for (b_sol_t=0, i_comp=0; i_comp<n_c; i_comp++)
    {
      if (DEPU) std::cout<<"--- compo = "<<i_comp<<std::endl;
      b_sol = solve_dumb_comp(flag, i_comp, true);
      if (DEPU) std::cout<<"--- b_sol = "<<b_sol<<std::endl;
      b_sol_t += b_sol;
    }

  if (DEPU) std::cout<<"--- SOL = "<<b_sol_t<<std::endl;
  return b_sol_t;
}

// Considera apenas os vertices do grafo com STATUS = flag de uma componente conexa 

int Sigraph::solve_dumb_comp(int flag, int compo, bool ini_C)
{
  int   v, b_sol;
  bool  sim;
  
  int    DEPU         = 0;

  if (DEPU) std::cout<<"-------- solve_dumb_comp -----------"<<std::endl;

  /* inicializa conjuntos solucao */
  if (ini_C)
    {
      vet1.set(0);
      vet2.set(0);
    }
  b_sol = 0;

  /* vertice inicial */
  for (sim=false, v=0; v<n; v++)
    if ((stat[v] == flag) && (comp[v] == compo))
      {
	sim = true;
	break;
      }
  
  if (sim)
    {
      if (DEPU) std::cout<<"   --- v_ini = "<<v<<" compo = "<<compo<<" flag = "<<flag<<std::endl;
      solve_dumb_rec(v, compo, b_sol, flag);
      if (DEPU) std::cout<<"   --- b_sol = "<<b_sol<<std::endl;
    }
  return b_sol;
} 


void Sigraph::solve_dumb_rec(int v, int compo, int &b_sol, int flag)
{
  int        i, j, v_p;
  bool       rami;

  int    DEPU         = 0;

  //if (DEPU) std::cout<<"       v entra em C1 ?"<<v<<std::endl;

  /*--------- ramo 1 ( v -> C1) --------- */

  /* testa C1 */
  rami = true;
  for (i=0;  i<n && rami; i++)
    if ((vet1[i] == 1) && (g(v,i).neg))
      {
	//if (DEPU) std::cout<<"        NAO) "<<i<<" em C1"<<std::endl;
	rami = false;
      }

  /* testa C2 */
  if (rami)
    {
      for (i=0; i<n && rami; i++)
	if ((vet2[i] == 1) && (g(v,i).pos))
	  {
	    //if (DEPU) std::cout<<"        NAO) "<<i<<" em C2"<<std::endl;
	    rami = false;
	  }
    }

  /* ramifica */
  if (rami)
    {
      vet1[v] = 1;
      //if (DEPU) std::cout<<"       "<<v<<" -> C1"<<std::endl;

      /* proximo vertice */
      for (rami=false, i=v+1; i<n; i++)
	if ((stat[i] == flag) && (comp[i] == compo))
	    {
	      rami = true;
	      v_p  = i;
	      break;
	    }
      
      if (rami)
	{
	  /* recursao */
	  solve_dumb_rec(v_p, compo, b_sol, flag);
	}
      else
	{
	  /* solucao */
	  for (j=0, i=0; i<n; i++)
	    if (vet1[i] == 1) j++;

	  for (i=0; i<n; i++)
	    if (vet2[i] == 1) j++;

	  if (j > b_sol)
	    {
	      b_sol = j;
	      if (DEPU) std::cout<<"         MELHOR SOLUCAO = "<<j<<std::endl;
	      if (DEPU) {std::cout<<"         C1 = "; vet1.imprime(); }
	      if (DEPU) {std::cout<<"         C2 = "; vet2.imprime(); }
	    }
	}

      vet1[v] = 0;
      //if (DEPU) std::cout<<"       "<<v<<" <- C1"<<std::endl;
    }


  //if (DEPU) std::cout<<"       v entra em C2 ?"<<v<<std::endl;

  /*--------- ramo 2 ( v -> C2) --------- */

  /* testa C2 */
  rami = true;
  for (i=0; i<n && rami; i++)
    if ((vet2[i] == 1) && (g(v,i).neg))
      {
	//if (DEPU) std::cout<<"        NAO) "<<i<<" em C2"<<std::endl;
	rami = false;
      }

  /* testa C1 */
  if (rami)
    {
      for (i=0; i<n && rami; i++)
	if ((vet1[i] == 1) && (g(v,i).pos))
	  {
	    //if (DEPU) std::cout<<"        NAO) "<<i<<" em C1"<<std::endl;
	    rami = false;
	  }
    }

  /* ramifica */
  if (rami)
    {
      vet2[v] = 1;
      //if (DEPU) std::cout<<"       "<<v<<" -> C2"<<std::endl;

      /* proximo vertice */
      for (rami=false, i=v+1; i<n; i++)
	if ((stat[i] == flag) && (comp[i] == compo))
	    {
	      rami = true;
	      v_p  = i;
	      break;
	    }
      
      if (rami)
	{
	  /* recursao */
	  solve_dumb_rec(v_p, compo, b_sol, flag);
	}
      else
	{
	  /* solucao */
	  for (j=0, i=0; i<n; i++)
	    if (vet1[i] == 1) j++;

	  for (i=0; i<n; i++)
	    if (vet2[i] == 1) j++;

	  if (j > b_sol)
	    {
	      b_sol = j;
	      if (DEPU) std::cout<<"         MELHOR SOLUCAO = "<<j<<std::endl;
	      if (DEPU) {std::cout<<"         C1 = "; vet1.imprime(); }
	      if (DEPU) {std::cout<<"         C2 = "; vet2.imprime(); }
	    }
	}

      vet2[v] = 0;
      //if (DEPU) std::cout<<"       "<<v<<" <- C2"<<std::endl;
    }


  /*--------- ramo 3 ( v -> nao entra) --------- */
  //if (DEPU) std::cout<<"       "<<v<<" nao "<<std::endl;

  /* proximo vertice */
  for (rami=false, i=v+1; i<n; i++)
    if ((stat[i] == flag) && (comp[i] == compo))
      {
	rami = true;
	v_p  = i;
	break;
      }
      
  if (rami)
    {
      /* recursao */
      solve_dumb_rec(v_p, compo, b_sol, flag);
    }
  else
    {
      /* solucao */
      for (j=0, i=0; i<n; i++)
	if (vet1[i] == 1) j++;
      
      for (i=0; i<n; i++)
	if (vet2[i] == 1) j++;
      
      if (j > b_sol)
	{
	  b_sol = j;
	  if (DEPU) std::cout<<"         MELHOR SOLUCAO = "<<j<<std::endl;
	  if (DEPU) {std::cout<<"         C1 = "; vet1.imprime(); }
	  if (DEPU) {std::cout<<"         C2 = "; vet2.imprime(); }
	}
    }

}


//------------------------------------------------------------------------------------

// Separacao S=1. O vetor atc contem as articulacoes que foram separadas e nao devemos tentar separar 
// novamente

bool  Sigraph::preproc_Separator_1(Array<int> &atc)
{
  int           i_comp, i, j, w, raiz=-1, cont1, cont2, cont, flag, n_a, n_b, nc;
  bool          art;
  Array<int>    prede;
  Array<int>    dista;
  Array<int>    cores;
  Array<int>    lowpt;
  Array<int>    artic;

  int    FLAG0          =-1;
  int    FLAG1          =-2;
  int    FLAG2          =-3;
  int    MAX_VERT_EXATO = 15;
  int    DEPU           = 0;

  if (DEPU) std::cout<<std::endl<<"***** preproc_Separator_1 ***** n_c = "<<n_c<<std::endl;

  // aloca 
  prede.aloca(n);
  dista.aloca(n);
  cores.aloca(n);
  lowpt.aloca(n);
  artic.aloca(n);     

  for (i_comp=0; i_comp<n_c; i_comp++)
    {
      if (DEPU) std::cout<<"------- preproc_Separator_1 comp = "<<i_comp<<std::endl;
  
      for(j=0, i=0; i<n; ++i)
	{
	  if ((comp[i] == i_comp) && (stat[i]==1))
	    {
	      raiz = i;
	      j++;
	    }
	}
      if (DEPU) std::cout<<"num_vert_comp = "<<j<<" raiz = "<<raiz<<" n = "<<n<<std::endl;
  
      // componente com apenas um vertice
      if (j <= 1)
	continue;
      
      // atribui
      prede.set(-1);      // predecessor
      dista.set(0);       // altura
      cores.set(0);       // 0 - BRANCO (nao entrou na pilha) , 1 - CINZA (na pilha), 2 - PRETO (ja saiu da pilha)
      artic.set(0);       // vetor de articulacoes  

      // inicializacao 
      prede[raiz] = raiz;
      lowpt[raiz] = raiz;
      for (i=0; i<n; i++)
	lowpt[i] = i;

      // Busca em profundidade recursiva 
      DFS_rec(raiz, prede, dista, cores,  lowpt);
      
      //prede.imprime();
      //lowpt.imprime();
      //dista.imprime();
      
      //identifica articulacoes
      for (i=0; i<n; ++i)
	if ((comp[i] == i_comp) && (stat[i]==1) && (i != raiz))
	  {
	    for (art=false, j=0; j<n; ++j) 
	      if ((comp[j] == i_comp) && (prede[j]==i) && (j != i))
		{
		  w = j;
		  if ((lowpt[w] == i) || (lowpt[w] == w))
		    {
		      art = true;
		      break;
		    }
		}
	    
	    if (art)
	      {
		artic[i] = 1; 
		if (DEPU) std::cout<<"  art = "<<i<<std::endl;
	      }
	  }
      
      // raiz articulacao ?
      for (w=0, j=0; j<n; ++j) 
	if ((comp[j] == i_comp))
	  if ((prede[j]==raiz) && (j != raiz))
	    w++;
      
      if (w > 1)
	{
	  artic[raiz] = 1; 
	  if (DEPU) std::cout<<"  raiz art = "<<raiz<<std::endl;
	}

      if (DEPU) std::cout<<"  Encontra separadores"<<std::endl;
      for (i=0; i<n; ++i)
	if ((artic[i]==1) && (atc[i]==0))
	  {
	    /* retira temporariamente o vertice do grafo */
	    stat[i] = FLAG0;
	    if (DEPU) std::cout<<"  S = "<<i<<std::endl;

	    /* encontra vizinho inicial */
	    for (j=0; j<n; ++j)
	      if (stat[j] == 1)
		if ((g(i,j).pos == true) || (g(i,j).neg == true))
		  break;
	    if (j == n) { std::cout<<"    ERRO ERRO ERRO j != n"; abort();}

	    // atribui
	    raiz = j;
	    prede.set(-1);  dista.set(0);  cores.set(0);  
	    if (DEPU) std::cout<<"     C comecando do = "<<j<<std::endl;
	    
	    // inicializacao 
	    prede[raiz] = raiz; lowpt[raiz] = raiz;
	    for (w=0; w<n; w++)
	      lowpt[w] = w;
	    
	    // Busca em profundidade recursiva 
	    DFS_rec(raiz, prede, dista, cores,  lowpt);
	    
	    // Marca e conta vertices percorridos 
	    if (DEPU) std::cout<<"     vertices percorridos = ";
	    for (cont1=0, w=0; w<n; w++)
	      if ((stat[w] == 1) && (cores[w] == 2))
		{
		  stat[w] = FLAG1;
		  cont1++;
		  if (DEPU) std::cout<<w<<", ";
		}
	    if (DEPU) std::cout<<std::endl<<"     n_c = "<<cont1<<std::endl;
	    
	    /* encontra vizinho inicial dou outro lado da articulacao */
	    for (j=0; j<n; ++j)
	      if (stat[j] == 1)
		if ((g(i,j).pos == true) || (g(i,j).neg == true))
		  break;
	    if (j == n) { std::cout<<"    ERRO2 ERRO2 ERRO2 j != n"; abort();}

	    // atribui
	    raiz = j;
	    prede.set(-1);  dista.set(0);  cores.set(0);  
	    if (DEPU) std::cout<<"     C comecando do = "<<j<<std::endl;
	    
	    // inicializacao 
	    prede[raiz] = raiz; lowpt[raiz] = raiz;
	    for (w=0; w<n; w++)
	      lowpt[w] = w;
	    
	    // Busca em profundidade recursiva 
	    DFS_rec(raiz, prede, dista, cores,  lowpt);
	    
	    // Marca e conta vertices percorridos 
	    if (DEPU) std::cout<<"     vertices percorridos = ";
	    for (cont2=0, w=0; w<n; w++)
	      if ((stat[w] == 1) && (cores[w] == 2))
		{
		  stat[w] = FLAG2;
		  cont2++;
		  if (DEPU) std::cout<<w<<", ";
		}
	    if (DEPU) std::cout<<std::endl<<"     n_C = "<<cont2<<std::endl;
	    
	    // retorna status dos vertices do lado maior (porque o que eu quero eh o menor) (menor > 2)
	    if (cont1 <= cont2) 
	      {
		for (w=0; w<n; w++)
		  if (stat[w] == FLAG2)
		    stat[w] = 1;
		cont = cont1;
		flag = FLAG1;
	      }
	    else
	      {
		for (w=0; w<n; w++)
		  if (stat[w] == FLAG1)
		    stat[w] = 1;
		cont = cont2;
		flag = FLAG2;
	      }

	    // solucao exata burra do lado menor 
	    if (cont < MAX_VERT_EXATO)
	      {
		// resolve com o vertice "i" sem pertencer a solucao 
		if (DEPU) std::cout<<std::endl<<"     executa exato em grafo com "<<cont<<" vertices"<<std::endl;
		n_b = solve_dumb_comp(flag, i_comp, true);
		if (DEPU) std::cout<<std::endl<<"     SOL sem i = "<<n_b<<std::endl;

		// resolve com o vertice "i" pertencendo a solucao 
		stat[i] = flag;
		vet1.set(0); vet2.set(0); vet1[i] = 1;
		n_a = solve_dumb_comp(flag, i_comp, false);
		n_a = n_a - 1; // tira o vertice i da solucao
		if (DEPU) std::cout<<std::endl<<"     SOL com i = "<<n_a<<std::endl;
		
		/* altera grafo */
		for (nc=0, w=0; w<n && (nc<(n_b-n_a)); w++)
		  if ((stat[w] == flag) && (w != i))
		    {
		      // isola vertice
		      delete_all_edge(w, 3);
		      
		      // cria aresta +- com vertice i
		      insert_edge(i, w, 3);

		      stat[w] = 1;
		      nc++;
		    }
		
		// o que sera adicionado na funcao objetivo
		n_add_preproc = n_add_preproc + n_a;
		
		// deleta os demais vertices e retorna vertice i 
		for (w=0; w<n; w++)
		  {
		    if (stat[w] == flag)
		      {
			stat[w] = -1;
			if (DEPU) std::cout<<std::endl<<"     DELETOU VERT "<<w<<std::endl;
		      }
		  }
		stat[i] = 1;

		// marca articulacao como ja separada e nao tentar separar de novo em outra chamada
		atc[i] = 1;
		if (DEPU) std::cout<<std::endl<<"     SEPAROU "<<i<<std::endl;

		/* ----- DEPURACAO ------- */
		/*if (DEPU) 
		  {
		    std::cout<<"POS"<<std::endl;
		    for (w=0; w<n; w++)
		      if (stat[w] == 1)
			{
			  if (DEPU) std::cout<<w<<") ";
			  for (j=0; j<n; j++)
			    if ((stat[j] == 1) && (g(w,j).pos))
			      if (DEPU) std::cout<<j<<", ";
			  if (DEPU) std::cout<<std::endl;
			}
		  }

		if (DEPU) 
		  {
		    std::cout<<"NEG"<<std::endl;
		    for (w=0; w<n; w++)
		      if (stat[w] == 1)
			{
			  if (DEPU) std::cout<<w<<") ";
			  for (j=0; j<n; j++)
			    if ((stat[j] == 1) && (g(w,j).neg))
			      if (DEPU) std::cout<<j<<", ";
			  if (DEPU) std::cout<<std::endl;
			}
			}*/

		// libera
		prede.desaloca();
		dista.desaloca();
		cores.desaloca();
		lowpt.desaloca();
		artic.desaloca();

		return true;
	      }
	    else
	      {
		if (DEPU) std::cout<<std::endl<<"     Ultrapassou limite de vertices do exato"<<std::endl;

		// retorna status dos vertices 
		for (w=0; w<n; w++)
		  if (stat[w] == flag)
		    stat[w] = 1;
		stat[i] = 1;
	      }

	  }/* for (i=0; i<n; ++i) */
      
    }/*  for (i_comp=0; i_comp<n_c; i_comp++) */
  
  // libera
  prede.desaloca();
  dista.desaloca();
  cores.desaloca();
  lowpt.desaloca();
  artic.desaloca();

  return false;
}


//-----------------------------------------------------------------------


/* GRASP para o problema do conjunto independente */
int Sigraph::grasp_stable_set(int TEST)
{
  int     i, ii, j, k, v, vsai, ventra, tam_v, tam_best;
  int     numcand, iteracoes;
  bool    parada, not_maximal, busca_local, aumentante;
  unsigned long int t_ini_g;

  /* PARAMETROS */
  int     PARADA   = 50;
  //int     MAXTIME  = TEMPOMAXGRASP; /* 5 min */

  /* vet1 = vetor do conjunto independente (CI)
     vet2 = vetor de candidatos a entrar no CI 
     vet3 = vetor dos candidatos aumentantes a entrar no CI (ao entrar o conjunto nao eh maximal, pode aumentar) 
     vet4 = vetor do melhor CI encontrado */

  int    DEPU           = 0;

  if (DEPU) std::cout<<std::endl<<"*************  grasp_stable_set() ****************** "<<std::endl;

  /* inicializacao */
  t_ini_g          = (unsigned long int) clock();
  iteracoes        = 0;
  parada           = true;
  tam_best         = 0;

  while (parada)
    {
      /* ------------------------------ FASE CONSTRUTIVA ------------------------------- */
      if (DEPU) std::cout<<" -------- FASE CONSTRUTIVA ------------"<<std::endl;

      /* inicializa clique */
      vet1.set(0);
      vet2.set(0);

      /* escolhe vertice inicial aleatorio */
      for (v = (int)(rand() % n); stat[v] != 1; v++)
	if (v == (n-1)) v = -1;
      vet1[v] = 1;
      if (DEPU) std::cout<<" v_ini = "<<v<<std::endl;

      /* preenche candidatos */
      if (DEPU) std::cout<<" cand = ";
      for (i=0, numcand = 0; i<n; i++)
	if ((stat[i] == 1) && (v != i))
	  {
	    vet2[i] = !(g(v,i).pos || g(v,i).neg);
	    if (vet2[i] == 1)
	      {
		numcand++;
		if (DEPU) std::cout<<i<<", ";
	      }
	  }
      if (DEPU) std::cout<<std::endl;

      /* constroi clique gulosa/aleatoria */
      if (numcand >= 1)
	{
	  if (DEPU) std::cout<<" -- Torna maximal --"<<std::endl;
	  not_maximal = true;
	  while (not_maximal)
	    {
	      /* pega um vertice aleatorio dos candidatos para colocar no CI */
	      for (v = (int)(rand() % n); vet2[v] != 1; v++)
		if (v == (n-1)) v = -1;

	      /* coloca vertice no CI */
	      vet1[v] = 1;
	      vet2[v] = 0;
	      if (DEPU) std::cout<<"    + "<<v<<std::endl;

	      /* atualiza candidatos */
	      if (DEPU) std::cout<<"    cand = ";
	      for (i=0, numcand = 0; i<n; i++)
		if (stat[i] == 1)
		  {
		    vet2[i] = (   vet2[i] &&  !(g(v,i).pos || g(v,i).neg)   );
		    if (vet2[i] == 1)
		      {
			numcand++;
			if (DEPU) std::cout<<i<<", ";
		      }
		  }
	      if (DEPU) std::cout<<std::endl;

	      /* parada */
	      if (numcand == 0) 
		{
		  not_maximal = false;
		  if (DEPU) std::cout<<"-- Sai do torna maximal --"<<std::endl;
		}
	      
	    }/* while (not_maximal) */
	}/* if (numcand >= 1) */

       /* ------------------------------ FASE BUSCA LOCAL ------------------------------- */
      if (DEPU) std::cout<<" -------- FASE BUSCA LOCAL ------------"<<std::endl;

      busca_local = true;
      while (busca_local)
	  {
	    /* retira um vertice */
	    for (ii=0, i=(int)(rand() % n), vsai = -1, ventra = -1; ii<n; i++, ii++)
	      {
		if (vet1[i] == 1)
		  {
		    /* candidatos a entrar na clique se "i" saisse (sem ser o "i") */
		    if (DEPU) std::cout<<" tenta tirar "<<i<<std::endl;

		    vet2.set(1);
		    vet2[i] = 0;
		    for (j=0; j<n; j++)
		      if ((vet1[j] == 1) && (j != i))
			{
			  vet2[j] = 0;
			  for (k=0; k<n; k++)
			    if (stat[k] == 1)
			      vet2[k] = (   vet2[k] && !(g(j,k).pos || g(j,k).neg)   );
			    else
			      vet2[k] = 0;
			}
		    
		    if (DEPU) 
		      {
			std::cout<<"    cand a entrar = ";
			for (j=0; j<n; j++)
			  if (vet2[j] == 1)
			    if (DEPU) std::cout<<j<<", ";
			if (DEPU) std::cout<<std::endl;
		    }
		    
		    /* para cada candidato "j" que entrar, checa se o CI ainda seria maximal ou se poderia aumentar mais */
                    if (DEPU) std::cout<<"    cand aumentantes a entrar = ";
		    vet3.set(0);
		    for (aumentante=false, j=0; j<n; j++)
		      if (vet2[j] == 1)
			{
			  for (k=0; k<n; k++)
			    if ((vet2[k] == 1) && (k != j))
			      if (!(g(j,k).pos || g(j,k).neg)) 
				{
				  vet3[j] = 1;
				  if (DEPU) std::cout<<j<<", ";
				  aumentante = true;
				}
			}
		    if (DEPU) std::cout<<std::endl;
		    
		    /* escolhe aleatoriamente, dentre os vertices que se entrarem vao aumentar o CI, */
		    if (aumentante)
		      {
			vsai   = i;
			for (ventra = (int)(rand() % n); vet3[ventra] != 1; ventra++)
			  if (ventra == (n-1)) ventra = -1;

			if (DEPU) std::cout<<" escolheu "<<ventra<<std::endl;
			break;
		      }

		  }/* if (vet1[i] == 1) */

		if (i == (n-1)) i = -1; // porque a posicao de inicio do laco eh random
	      }/*  for (ii=0, i=(int)(rand() % n), vsai = -1, ventra = -1; ii<n; i++, ii++) */

	    /* parada */
	    if (vsai == -1)
	      {
		busca_local = false;
		if (DEPU) std::cout<<"-- Sem mais melhorias. Sai da Busca Local  --"<<std::endl;
		continue;
	      }
	    /* realiza a troca */
	    else
	      {
		vet1[vsai]   = 0;
		vet1[ventra] = 1;
		if (DEPU) std::cout<<" sai "<<vsai<<" entra "<<ventra<<std::endl;

		/* gera candidatos para expansao do CI */
		vet2.set(1);
		for (j=0; j<n; j++)
		  if (vet1[j] == 1)
		    {
		      vet2[j] = 0;
		      for (k=0; k<n; k++)
			if (stat[k] == 1)
			  vet2[k] = (   vet2[k] && !(g(j,k).pos || g(j,k).neg)   );
			else
			  vet2[k] = 0;
		    }

		if (DEPU) 
		  {
		    std::cout<<"    cand a expansao = ";
		    for (j=0; j<n; j++)
		      if (vet2[j] == 1)
			if (DEPU) std::cout<<j<<", ";
		    if (DEPU) std::cout<<std::endl;
		  }
	      }

	    /* expande CI */
	    if (DEPU) std::cout<<" -- Torna maximal --"<<std::endl;

	    not_maximal = true;
	    while (not_maximal)
	      {
		/* pega um vertice aleatorio dos candidatos para colocar no CI */
		for (v = (int)(rand() % n); vet2[v] != 1; v++)
		  if (v == (n-1)) v = -1;
		
		/* coloca vertice no CI */
		vet1[v] = 1;
		vet2[v] = 0;
		if (DEPU) std::cout<<"    + "<<v<<std::endl;

		/* atualiza candidatos */
		if (DEPU) std::cout<<"    cand = ";
		for (i=0, numcand = 0; i<n; i++)
		  if (stat[i] == 1)
		    {
		      vet2[i] = (   vet2[i] &&  !(g(v,i).pos || g(v,i).neg)   );
		      if (vet2[i] == 1)
			{
			  numcand++;
			  if (DEPU) std::cout<<i<<", ";
			}
		    }
		if (DEPU) std::cout<<std::endl;
	      
		/* parada */
		if (numcand == 0) 
		  {
		    not_maximal = false;
		    if (DEPU) std::cout<<"-- Sai do torna maximal --"<<std::endl;
		  }
	      }
	    
	    /* teste de parada por tempo */
	    if (calcula_tempo(t_ini_g, (unsigned long int) clock()) > TEMPOMAXGRASP)
	      {
		busca_local = false;
		if (DEPU) std::cout<<"-- Acabou o tempo - Sai da Busca Local  --"<<std::endl;
		continue;
	      }

	  }/* while (busca_local) */

	/* -------------------------- GUARDA MELHORES SOLUCOES E PARADA ----------------------------------- */

	/* tamanho do CI */
	for (tam_v=0, i=0; i<n; i++)
	  if (vet1[i] == 1)
	    tam_v++;

	if (DEPU) std::cout<<"it = "<<iteracoes<<std::endl;

	if (tam_v > tam_best)
	  {
	    /* armazena melhor solucao */
		if (DEPU) 
		  {
		    std::cout<<"************** MELHOR SOLUCAO COM **************** "<<tam_v<<" vertices"<<std::endl;
		    for (i=0; i<n; i++)
		      if (vet1[i] == 1)
			std::cout<<i<<", ";
		    std::cout<<std::endl;
		  }

	    if (TEST)
	      {
		for (i=0; i<n; i++)
		  if (vet1[i] == 1)
		    for (j=i+1; j<n; j++)
		      if (vet1[j] == 1)
			if ((g(i,j).pos || g(i,j).neg))
			  {std::cout<<"ERRO ERRO ERRO - Nao eh CI "<<std::endl; abort();}
	      }

	    for (i=0; i<n; i++)
	      vet4[i] = vet1[i];
	    tam_best = tam_v;

	    /* se achou solucao melhor, zera iteracoes */
	    iteracoes = 0;
	  }

	/* parada */
	iteracoes++;
	if (DEPU) std::cout<<"                      ** IT = "<<iteracoes<<std::endl;
	if (iteracoes >= (PARADA))
	  {
	    parada = false;
	    if (DEPU) std::cout<<" ----------- ACABOU ------------"<<std::endl;
	    continue;
	  }

	/* teste de parada por tempo */
	if (DEPU) std::cout<<"TEMPO = "<<calcula_tempo(t_ini_g, (unsigned long int) clock())<<" seg"<<std::endl;
        if (calcula_tempo(t_ini_g, (unsigned long int) clock()) > TEMPOMAXGRASP)
          {
            parada = false;
            if (DEPU) std::cout<<" ----------- ACABOU TEMPO ------------"<<std::endl;
            continue;
          }

    }/* while (parada) */
  
  return tam_best;
}

//---------------------------------------------------------------------------------------------------------
//---------------------------------------------------------------------------------------------------------
//---------------------------------------------------------------------------------------------------------

/* vizinhanca do GRASP para o problema do grafo de sinais */
void Sigraph::testa_particoes_grasp_sig_v2(Array<int> &A, Array<int> &a, Array<int> &B, Array<int> &b, Array<int> &C, Array<int> &c)
{
  int  ii,jj;
  bool achou;

  // testa A,B
  for (ii=0; ii<n; ii++)
    for (jj=ii+1; jj<n; jj++)
      if ((A[ii] == 1) && (A[jj] == 1) && (g(ii, jj).neg))
	{ std::cout<<"vertice "<<ii<<" (A)"<<" e vertice "<<jj<<" (A) tem are neg"<<std::endl; abort(); }
  
  for (ii=0; ii<n; ii++)
    for (jj=ii+1; jj<n; jj++)
      if ((B[ii] == 1) && (B[jj] == 1) && (g(ii, jj).neg))
	{ std::cout<<"vertice "<<ii<<" (B)"<<" e vertice "<<jj<<" (B) tem are neg"<<std::endl; abort(); }
  
  for (ii=0; ii<n; ii++)
    for (jj=0; jj<n; jj++)
      if ((A[ii] == 1) && (B[jj] == 1) && (g(ii, jj).pos))
	{ std::cout<<"vertice "<<ii<<" (A)"<<" e vertice "<<jj<<" (B) tem are pos"<<std::endl; abort(); }

  for (ii=0; ii<n; ii++)
    if (A[ii]+B[ii]+C[ii] != 1)
	{ std::cout<<"soma do vertice "<<ii<<" = "<<A[ii]+B[ii]+C[ii]<<std::endl; abort(); }

  // testa a,b,c
  for (ii=0; a[ii]!=-1; ii++)
    if ((a[ii] != -2) && (A[a[ii]] == 0))
      { std::cout<<"vertice "<<a[ii]<<" em (a), mas nao esta em (A)"<<std::endl; abort(); }

  for (ii=0; b[ii]!=-1; ii++)
    if ((b[ii] != -2) && (B[b[ii]] == 0))
      { std::cout<<"vertice "<<b[ii]<<" em (b), mas nao esta em (B)"<<std::endl; abort(); }

  for (ii=0; c[ii]!=-1; ii++)
    if ((c[ii] != -2) && (C[c[ii]] == 0))
      { std::cout<<"vertice "<<c[ii]<<" em (c), mas nao esta em (C)"<<std::endl; abort(); }

  for (ii=0; ii<n; ii++)
    if (A[ii] == 1)
      {
	for (achou=false, jj=0; a[jj]!=-1; jj++)
	  if (a[jj] == ii)
	    {
	      achou = true;
	      break;
	    }
	if (!achou) 
	  { std::cout<<"vertice "<<ii<<" em (A), mas nao esta em (a)"<<std::endl; abort(); }
      }

  for (ii=0; ii<n; ii++)
    if (B[ii] == 1)
      {
	for (achou=false, jj=0; b[jj]!=-1; jj++)
	  if (b[jj] == ii)
	    {
	      achou = true;
	      break;
	    }
	if (!achou) 
	  { std::cout<<"vertice "<<ii<<" em (B), mas nao esta em (b)"<<std::endl; abort(); }
      }

  for (ii=0; ii<n; ii++)
    if (C[ii] == 1)
      {
	for (achou=false, jj=0; c[jj]!=-1; jj++)
	  if (c[jj] == ii)
	    {
	      achou = true;
	      break;
	    }
	if (!achou) 
	  { std::cout<<"vertice "<<ii<<" em (C), mas nao esta em (c)"<<std::endl; abort(); }
      }
}


/* atualiza vetores a e b */
void Sigraph::atualiza_a_b_c(Array<int> &A, Array<int> &a, Array<int> &B, Array<int> &b,  Array<int> &C, Array<int> &c)
{
  int temA, temB, temC, i;

  for (temA=temB=temC=i=0; i<n; i++)
    {
      if (A[i]==1)
	{
	  a[temA] = i;
	  temA++;
	}
      if (B[i]==1)
	{
	  b[temB] = i;
	  temB++;
	}
      if (C[i]==1)
	{
	  c[temC] = i;
	  temC++;
	}
    }
  a[temA] = -1;
  b[temB] = -1;
  c[temC] = -1;
}


/* metodo construtivo do GRASP para o problema do grafo de sinais */
int Sigraph::metodo_construtivo_grasp_sig_v2(Array<int> &A, Array<int> &a, Array<int> &B, Array<int> &b, Array<int> &C,  Array<int> &c, Array<int> &cand1, Array<int> &cand2, int TEST)
{
  int     i, j, v, vez, temA, temB, num_cand, num_sol;
  bool    e_cand;

  int     DEPU           = 0;

  if (DEPU) std::cout<<std::endl<<"*************  metodo_construtivo_grasp_sig  ****************** "<<std::endl;

  /* inicializa conjuntos */
  A.set(0);
  B.set(0);
  C.set(1);
 
  /* escolhe vertice inicial aleatorio e coloca em A */
  for (v = (int)(rand() % n); stat[v] != 1; v++)
    if (v == (n-1)) v = -1;
  A[v] = 1; C[v] = 0;
  num_sol = 1;

  if (DEPU) std::cout<<" v_ini = "<<v<<" em A"<<std::endl;

  /* tenta botar a proxima vez no lado B */
  vez  = 0;
  temA = 1;
  temB = 1;

  while ((temA == 1) || (temB == 1))
    {
      /* preenche candidatos a entrar em A */
      if (vez == 1)
	{
	  cand1.set(0);
	  for (i=0, num_cand = 0; i<n; i++)
	    if ((stat[i] == 1) && (C[i] == 1))
	      {
		/* checa vizinhanca em A */
		for (e_cand=true, j=0; j<n && e_cand==true; j++)
		  if ((A[j]==1) && (g(i,j).neg))
		    e_cand = false;
		
		/* checa vizinhanca em B */
		for (j=0; j<n && e_cand==true; j++)
		  if ((B[j]==1) && (g(i,j).pos))
		    e_cand = false;
		
		if (e_cand)
		  {
		    cand1[i]=1;
		    num_cand++;
		  }
	      }

	  /* não tem mais vertice para inserir em A */
	  if (num_cand==0)
	    temA = 0;
	}
      else
	{
	  /* preenche candidatos a entrar em B */
	  cand1.set(0);
	  for (i=0, num_cand = 0; i<n; i++)
	    if ((stat[i] == 1) && (C[i] == 1))
	      {
		/* checa vizinhanca em A */
		for (e_cand=true, j=0; j<n && e_cand==true; j++)
		  if ((A[j]==1) && (g(i,j).pos))
		    e_cand = false;
		
		/* checa vizinhanca em B */
		for (j=0; j<n && e_cand==true; j++)
		  if ((B[j]==1) && (g(i,j).neg))
		    e_cand = false;
		
		if (e_cand)
		  {
		    cand1[i]=1;
		    num_cand++;
		  }
	      }

	  /* não tem mais vertice para inserir em B */
	  if (num_cand==0)
	    temB = 0;
	}

      /* insere em A */
      if ((vez == 1) && (num_cand > 0))
	{
	  /* escolhe vertice candidato aleatorio e coloca em A */
	  for (v = (int)(rand() % n); (stat[v] != 1 || cand1[v] != 1); v++)
	    if (v == (n-1)) v = -1;
	  A[v] = 1; C[v] = 0; num_sol++;
	  if (DEPU) std::cout<<"   "<<v<<" em A"<<std::endl;
	}

      /* insere em B */
      if ((vez == 0) && (num_cand > 0))
	{
	  /* escolhe vertice candidato aleatorio e coloca em B */
	  for (v = (int)(rand() % n); (stat[v] != 1 || cand1[v] != 1); v++)
	    if (v == (n-1)) v = -1;
	  B[v] = 1; C[v] = 0; num_sol++;
	  if (DEPU) std::cout<<"   "<<v<<" em B"<<std::endl;
	}

      /* escolhe proxima particao para ser inserido vertice */
      if (temA == 1 && temB == 1)
	vez = (int)(rand() % 2);
      else
	if (temA == 1) vez = 1;
	else           vez = 0;
      if (DEPU) std::cout<<"escolhe de "<<vez<<" agora"<<std::endl;

    }/* while ((temA == 1) || (temB == 1)) */
  
  // /* prenche vetores "a" e "b" */
  if (DEPU) std::cout<<"prenche vetores a e b"<<std::endl;
  atualiza_a_b_c(A, a, B, b, C, c);

  if (TEST) testa_particoes_grasp_sig_v2(A, a, B, b, C, c);
  return num_sol;
}




/* metodo construtivo do GRASP para o problema do grafo de sinais */
void Sigraph::maximiza_solucao_grasp_sig_v2(Array<int> &A, Array<int> &a, Array<int> &B, Array<int> &b, Array<int> &C,  Array<int> &c, Array<int> &cand1, Array<int> &cand2, int TEST)
{
  int     i, v, vez, temA, temB, num_cand;
  int     DEPU           = 0;

  //if (DEPU) std::cout<<std::endl<<"*************  maximiza_solucao_grasp_sig_v2  ****************** "<<std::endl;

  /* tenta botar a proxima vez no lado B */
  vez = (int)(rand() % 2);
  temA = 1;
  temB = 1;

  while ((temA == 1) || (temB == 1))
    {
      /* preenche candidatos a entrar em A */
      if (vez == 1)
	{
	  for (num_cand=0, i=0; c[i]!=-1; i++)
	    if ((c[i] != -2) && (stat[c[i]] == 1))
	      {
		if (can_move_C_X_v2(c[i], a, b, C))
		  {
		    cand1[num_cand]=c[i];
		    num_cand++;
		  }
	      }

	  /* nao tem mais vertice para inserir em A */
	  if (num_cand==0)
	    temA = 0;
	}
      else
	{
	  /* preenche candidatos a entrar em B */
	  for (num_cand=0, i=0; c[i]!=-1; i++)
	    if ((c[i] != -2) && (stat[c[i]] == 1))
	      {
		if (can_move_C_X_v2(c[i], b, a, C))
		  {
		    cand1[num_cand]=c[i];
		    num_cand++;
		  }
	      }

	  /* nao tem mais vertice para inserir em B */
	  if (num_cand==0)
	    temB = 0;
	}

      /* insere em A */
      if ((vez == 1) && (num_cand > 0))
	{
	  /* escolhe vertice candidato aleatorio e coloca em A */
	  v = (int)(rand() % num_cand);
	  A[cand1[v]] = 1; C[cand1[v]] = 0; 
	  atualiza_a_b_c(A, a, B, b, C, c);
	  if (DEPU) std::cout<<"      MAX "<<cand1[v]<<" de C para A"<<std::endl;
	}

      /* insere em B */
      if ((vez == 0) && (num_cand > 0))
	{
	  /* escolhe vertice candidato aleatorio e coloca em A */
	  v = (int)(rand() % num_cand);
	  B[cand1[v]] = 1; C[cand1[v]] = 0; 
	  atualiza_a_b_c(A, a, B, b, C, c);
	  if (DEPU) std::cout<<"      MAX "<<cand1[v]<<" de C para B"<<std::endl;
	}

      /* escolhe proxima particao para ser inserido vertice */
      if (temA == 1 && temB == 1)
	vez = (int)(rand() % 2);
      else
	if (temA == 1) vez = 1;
	else           vez = 0;
      //if (DEPU) std::cout<<"escolhe de "<<vez<<" agora"<<std::endl;

    }/* while ((temA == 1) || (temB == 1)) */
  
  if (TEST) testa_particoes_grasp_sig_v2(A, a, B, b, C, c);
}




/* testa se pode mover um vertice "l" de C para X (A ou B) e nao Y (A ou B diferente de X) */
bool Sigraph::can_move_C_X_v2(int l, Array<int> &x, Array<int> &y, Array<int> &C)
{
  int       j;
  bool      e_cand;
  int       DEPU = 0;

  if ((stat[l] == 1) && (C[l] == 1))
    {
      for (e_cand=true, j=0; x[j]!=-1 && e_cand==true; j++)
	if ((x[j] != -2) && (g(l,x[j]).neg))
	  {
	    e_cand = false;
	    if (DEPU) std::cout<<l<<"    are neg com "<<x[j]<<std::endl;
	  }
      
      for (j=0; y[j]!=-1 && e_cand==true; j++)
	if ((y[j] != -2) && (g(l,y[j]).pos))
	  {
	    e_cand = false;
	    if (DEPU) std::cout<<l<<"  are pos com "<<y[j]<<std::endl;
	  }

      return e_cand;
    }
  return false;
}


/* testa se pode mover dois vertices "l1" e "l2" de C para X (A ou B) e nao Y (A ou B diferente de X) */
bool Sigraph::can_2move_C_X_v2(int l1, int l2, Array<int> &x, Array<int> &y, Array<int> &C)
{
  int       j;
  bool      e_cand;
  
  if ((stat[l1] == 1) && (C[l1] == 1) && (stat[l2] == 1) && (C[l2] == 1))
    {
      if (g(l1,l2).neg)
	return false;

      for (e_cand=true, j=0; x[j]!=-1 && e_cand==true; j++)
	if ((x[j] != -2) && ((g(l1,x[j]).neg) || (g(l2,x[j]).neg)))
	  e_cand = false;
	  
      for (j=0; y[j]!=-1 && e_cand==true; j++)
	if ((y[j] != -2) && ((g(l1,y[j]).pos) || (g(l2,y[j]).pos)))
	  e_cand = false;
      
      return e_cand;
    }
  return false;
}






/* testa se pode mover um vertice "l" de C para A ou B -> 0 nao pode, 1 pode para A, 2 pode para B */
int Sigraph::can_move_C_AB_v2(int l, Array<int> &a, Array<int> &b, Array<int> &C, int TEST)
{
  int       vez;
  bool      testa_A, testa_B;

  if ((stat[l] == 1) && (C[l] == 1))
    {
      testa_A = false;
      testa_B = false;
      vez = (int)(rand() % 2);

      while (!testa_A || !testa_B)
	{
	  /* -> A */
	  if ((vez == 1) && (!testa_A))
	    {
              if (can_move_C_X_v2(l, a, b, C))
                return 1;
	      
	      testa_A = true;
	      vez     = 0;
	    }
	  
	  /* -> B */
	  if ((vez == 0) && (!testa_B))
	    {
              if (can_move_C_X_v2(l, b, a, C))
                return 2;
      
	      testa_B = true;
	      vez     = 1;
	    }
	  
	}/* while (!testa_A || !testa_B) */
      
    }/* if ((stat[l] == 1) && (C[l] == 1)) */
  
  return 0;
}




/* testa se pode mover dois vertices "c[l1]" e "c[l2]" de C para A ou B -> 
0 nao pode, 
1 pode, c[l1] (A) c[l2] (A) 
2 pode, c[l1] (A) c[l2] (B)
3 pode, c[l1] (B) c[l2] (A)
4 pode, c[l1] (B) c[l2] (B)
*/
int Sigraph::can_2move_C_AB_v2(int l1, int l2, int num_candA, int num_candB, Array<int> &a, Array<int> &b, Array<int> &C, Array<int> &c, int TEST)
{
  int       vez;
  bool      testa_AA, testa_AB, testa_BA, testa_BB;

  if ((stat[c[l1]] == 1) && (C[c[l1]] == 1) && (stat[c[l2]] == 1) && (C[c[l2]] == 1))
    {
      testa_AA = false;
      testa_AB = false; 
      testa_BA = false;
      testa_BB = false;
      vez = (int)(rand() % 4);

      while (!testa_AA || !testa_AB || !testa_BA || !testa_BB)
	{
	  /* -> AA */
	  if ((vez == 0) && (!testa_AA))
	    {
	      if (can_2move_C_X_v2(c[l1], c[l2], a, b, C))
		return 1;
      	      
	      testa_AA = true;
	      vez      = 1;
	    }
	  
	  /* -> AB */
	  if ((vez == 1) && (!testa_AB))
	    {
              if (can_move_C_X_v2(c[l1], a, b, C))
                {
		  a[num_candA]   = c[l1]; 
		  a[num_candA+1] = -1;
		  c[l1]          = -2;

		  if (can_move_C_X_v2(c[l2], b, a, C))
		    {
		      c[l1] = a[num_candA]; a[num_candA] = -1;
		      return 2;
		    }
		  c[l1] = a[num_candA]; a[num_candA] = -1;
		}
      
	      testa_AB = true;
	      vez      = 2;
	    }

	  /* -> BA */
	  if ((vez == 2) && (!testa_BA))
	    {
              if (can_move_C_X_v2(c[l1], b, a, C))
                {
		  b[num_candB]   = c[l1]; 
		  b[num_candB+1] = -1;
		  c[l1]          = -2;

		  if (can_move_C_X_v2(c[l2], a, b, C))
		    {
		      c[l1] = b[num_candB]; b[num_candB] = -1;
		      return 3;
		    }
		  c[l1] = b[num_candB]; b[num_candB] = -1;
		}
      
	      testa_BA = true;
	      vez      = 3;
	    }

	  /* -> BB */
	  if ((vez == 3) && (!testa_BB))
	    {
	      if (can_2move_C_X_v2(c[l1], c[l2], b, a, C))
		return 4;
      	      
	      testa_BB = true;
	      vez      = 0;
	    }

	}/* while (!testa_AA || !testa_AB || !testa_BA || !testa_BB) */
      
    }/* if ((stat[l1] == 1) && (C[l1] == 1) && (stat[l2] == 1) && (C[l2] == 1)) */
  
  return 0;
}







/* tenta mover 2 vertices de C para A ou B */
bool Sigraph::move_2_C_AB_v2(int desceu, int origem, Array<int> &A, Array<int> &a, Array<int> &B, Array<int> &b, Array<int> &C, Array<int> &c, Array<int> &cand1, Array<int> &cand2, int TEST)
{
  int       j, l, parada_2, parada_3, vert_swap, i_swap, vez, num_candA, num_candB, num_candC;
  bool      e_cand, moveu, testa_A, testa_B;

  int       DEPU = 0;

  moveu   = false;
  testa_A = false;
  testa_B = false;
  vez     = (int)(rand() % 2);

  /* ----------------------------- conta vertices (incluindo -2) */
  for (num_candA=0; a[num_candA]!=-1; num_candA++);
  for (num_candB=0; b[num_candB]!=-1; num_candB++);
  for (num_candC=0; c[num_candC]!=-1; num_candC++);

  while ((!testa_A || !testa_B) && (!moveu))
    {
      /* -----------> 2 NIVEL) C -> A */
      if ((vez == 1) && (!moveu) && (!testa_A))
	{
	  for (parada_2=num_candC, i_swap=(int)(rand() % num_candC); parada_2 > 0 && (moveu==false); i_swap++)
	    {
	      vert_swap    = c[i_swap];
	      if ((vert_swap != -2) && (stat[vert_swap] == 1) && (C[vert_swap] == 1) && ((desceu != vert_swap) || (origem != 0)))
		{
                  e_cand = can_move_C_X_v2(vert_swap, a, b, C);

		  if (e_cand)
		    {
		      if (DEPU) std::cout<<std::endl<<"  vert_CA = "<<vert_swap<<std::endl;
		      A[vert_swap]   = 1; 
		      C[vert_swap]   = 0;
		      c[i_swap]      = -2;
		      a[num_candA]   = vert_swap;
		      a[num_candA+1] = -1;

		      /* 3 NIVEL) C -> A ou B */
		      for (parada_3=num_candC, l=(int)(rand() % num_candC); parada_3 > 0 && (moveu==false); l++)
			{
			  if (c[l] != -2)
			    {
			      j = can_move_C_AB_v2(c[l], a, b, C, TEST);
			      
			      if (j == 1)
				{
				  if (DEPU) std::cout<<std::endl<<"    vert_CA = "<<c[l]<<" MOVEU !"<<std::endl;
				  A[c[l]]  = 1; C[c[l]]  = 0; 
				  atualiza_a_b_c(A, a, B, b, C, c);
				  moveu = true;
				}
			      if (j == 2)
				{
				  if (DEPU) std::cout<<std::endl<<"    vert_CB = "<<c[l]<<" MOVEU !"<<std::endl;
				  B[c[l]]  = 1; C[c[l]]  = 0; 
				  atualiza_a_b_c(A, a, B, b, C, c);
				  moveu = true;
				}
			    }
			  
			  if (l == (num_candC-1)) l = -1;
			  parada_3--;
			}
		      
		      if (!moveu)
			{
			  C[vert_swap] = 1;
			  A[vert_swap] = 0;
			  c[i_swap]    = vert_swap;
			  a[num_candA] = -1;
			  if (TEST) testa_particoes_grasp_sig_v2(A, a, B, b, C, c);
			}
		      
		    }/* if (e_cand)  */
		  
		}/*  if ((vert_swap != -2) && (stat[vert_swap] == 1) &&...  */
	      
	      if (i_swap == (num_candC-1)) i_swap = -1;
	      parada_2--;
	      
	    }/* for (parada_2=n, i=(int)(rand() % n); parada_2 > 0 && (moveu==false); i++) */
	  
	  testa_A = true;
	  vez     = 0;
	}/* if (vez == 1) */
      


      /* -----------> 2 NIVEL) C -> B */
      if ((vez == 0) && (!moveu) && (!testa_B))
	{
	  for (parada_2=num_candC, i_swap=(int)(rand() % num_candC); parada_2 > 0 && (moveu==false); i_swap++)
	    {
	      vert_swap    = c[i_swap];
	      if ((vert_swap != -2) && (stat[vert_swap] == 1) && (C[vert_swap] == 1) && ((desceu != vert_swap) || (origem != 1)))
		{
		  e_cand = can_move_C_X_v2(vert_swap, b, a, C);

		  if (e_cand)
		    {
		      if (DEPU) std::cout<<std::endl<<"  vert_CB = "<<vert_swap<<std::endl;
		      B[vert_swap]   = 1;
		      C[vert_swap]   = 0;
		      c[i_swap]      = -2;
		      b[num_candB]   = vert_swap;
		      b[num_candB+1] = -1;

		      /* 3 NIVEL) C -> A ou B */
		      for (parada_3=num_candC, l=(int)(rand() % num_candC); parada_3 > 0 && (moveu==false); l++)
			{
			  if (c[l] != -2)
			    {
			      j = can_move_C_AB_v2(c[l], a, b, C, TEST);

			      if (j == 1)
				{
				  if (DEPU) std::cout<<std::endl<<"    vert_CA = "<<c[l]<<" MOVEU !"<<std::endl;
				  A[c[l]]  = 1; C[c[l]]  = 0; 
				  atualiza_a_b_c(A, a, B, b, C, c);
				  moveu = true;
				}
			      if (j == 2)
				{
				  if (DEPU) std::cout<<std::endl<<"    vert_CB = "<<c[l]<<" MOVEU !"<<std::endl;
				  B[c[l]]  = 1; C[c[l]]  = 0; 
				  atualiza_a_b_c(A, a, B, b, C, c);
				  moveu = true;
				}
			    }

			  if (l == (num_candC-1)) l = -1;
			  parada_3--;
			}
		      
		      if (!moveu)
			{
			  C[vert_swap] = 1;
			  B[vert_swap] = 0;
			  c[i_swap]    = vert_swap;
			  b[num_candB] = -1;
			  if (TEST) testa_particoes_grasp_sig_v2(A, a, B, b, C, c);
			}	
		      
		    }/* if (e_cand)  */
		  
		}/* if ((vert_swap != -2) && (stat[vert_swap] == 1) && ... */
	      
	      if (i_swap == (num_candC-1)) i_swap = -1;
	      parada_2--;
	      
	    }/* for (parada_2=num_cand, i_swap=(int)(rand()... */
	  
	  testa_B = true;
	  vez     = 1;
	}/* if (vez == 0)*/
      
    }/* while (!testa_A || !testa_B) */

  return moveu;
}



/* tenta mover 3 vertices de C para A ou B */
bool Sigraph::move_3_C_AB_v2(int desceu1, int desceu2, int origem1, int origem2, Array<int> &A, Array<int> &a, Array<int> &B, Array<int> &b, Array<int> &C, Array<int> &c, Array<int> &cand1, Array<int> &cand2, int TEST)
{
  int       j, l1, l2, parada_2, parada_3, parada_4, vert_swap, i_swap, vez, num_candA, num_candB, num_candC;
  bool      e_cand, moveu, testa_A, testa_B;

  int       DEPU = 0;

  moveu   = false;
  testa_A = false;
  testa_B = false;
  vez     = (int)(rand() % 2);

  /* ----------------------------- conta vertices (incluindo -2) */
  for (num_candA=0; a[num_candA]!=-1; num_candA++);
  for (num_candB=0; b[num_candB]!=-1; num_candB++);
  for (num_candC=0; c[num_candC]!=-1; num_candC++);

  while ((!testa_A || !testa_B) && (!moveu))
    {
      /* -----------> 2 NIVEL) C -> A */
      if ((vez == 1) && (!moveu) && (!testa_A))
	{
	  for (parada_2=num_candC, i_swap=(int)(rand() % num_candC); parada_2 > 0 && (moveu==false); i_swap++)
	    {
	      vert_swap    = c[i_swap];

	      if ((vert_swap != -2) && (stat[vert_swap] == 1) && (C[vert_swap] == 1) && ((desceu1 != vert_swap) || (origem1 != 0)) && ((desceu2 != vert_swap) || (origem2 != 0)))
		{
		  e_cand = can_move_C_X_v2(vert_swap, a, b, C);
		  
		  if (e_cand)
		    {
		      if (DEPU) std::cout<<std::endl<<"  vert_CA = "<<vert_swap<<std::endl;
		      A[vert_swap]   = 1; 
		      C[vert_swap]   = 0;
		      c[i_swap]      = -2;
		      a[num_candA]   = vert_swap;
		      a[num_candA+1] = -1;
		    
		      /* 3 NIVEL) 2C -> A ou B */
		      for (parada_3=num_candC, l1=(int)(rand() % num_candC); parada_3 > 0 && (moveu==false); l1++)
			{
			  if ((c[l1] != -2) && (stat[c[l1]] == 1) && (C[c[l1]] == 1))
			    if (   (can_move_C_X_v2(c[l1], a, b, C))  ||  (can_move_C_X_v2(c[l1], b, a, C)  ))
			      for (parada_4=num_candC, l2=(int)(rand() % num_candC); parada_4 > 0 && (moveu==false); l2++)
				{
				  if ((c[l2] != -2) && (c[l1] < c[l2]) && (stat[c[l2]] == 1) && (C[c[l2]] == 1))
				    {
				      j = can_2move_C_AB_v2(l1, l2, num_candA+1, num_candB, a, b, C, c, TEST);
				      
				      if (j == 1)
					{
					  if (DEPU) std::cout<<std::endl<<"    vert_C_AA = "<<l1<<","<<l2<<" 2MOVEU !"<<std::endl;
					  A[c[l1]]  = 1; C[c[l1]]  = 0; A[c[l2]]  = 1; C[c[l2]]  = 0; 
					  atualiza_a_b_c(A, a, B, b, C, c); moveu = true;
					}
				      if (j == 2)
					{
					  if (DEPU) std::cout<<std::endl<<"    vert_C_AB = "<<l1<<","<<l2<<" 2MOVEU !"<<std::endl;
					  A[c[l1]]  = 1; C[c[l1]]  = 0; B[c[l2]]  = 1; C[c[l2]]  = 0; 
					  atualiza_a_b_c(A, a, B, b, C, c); moveu = true;
					}
				      if (j == 3)
					{
					  if (DEPU) std::cout<<std::endl<<"    vert_C_BA = "<<l1<<","<<l2<<" 2MOVEU !"<<std::endl;
					  B[c[l1]]  = 1; C[c[l1]]  = 0; A[c[l2]]  = 1; C[c[l2]]  = 0; 
					  atualiza_a_b_c(A, a, B, b, C, c); moveu = true;	
					}
				      if (j == 4)
					{
					  if (DEPU) std::cout<<std::endl<<"    vert_C_BB = "<<l1<<","<<l2<<" 2MOVEU !"<<std::endl;
					  B[c[l1]]  = 1; C[c[l1]]  = 0; B[c[l2]]  = 1; C[c[l2]]  = 0; 
					  atualiza_a_b_c(A, a, B, b, C, c); moveu = true;
					}
				    }/*if ((c[l2] != -2) && (c[l1] < c[l2]) && (stat[c[l2]] == 1) && (C[c[l2]] == 1)) */
				  
				  if (l2 == (num_candC-1)) l2 = -1;
				  parada_4--;
				}/* for (parada_4=num_candC, l2=(int)(rand() % num_candC); parada_4 > 0 && (moveu==false); l2++) */
			  
			  if (l1 == (num_candC-1)) l1 = -1;
			  parada_3--;
			}/* for (parada_3=num_candC, l1=(int)(rand() % num_candC); parada_3 > 0 && (moveu==false); l1++) */

		      if (!moveu)
			{
			  C[vert_swap] = 1;
			  A[vert_swap] = 0;
			  c[i_swap]    = vert_swap;
			  a[num_candA] = -1;
			  if (TEST) testa_particoes_grasp_sig_v2(A, a, B, b, C, c);
			}
		    }/* if (e_cand)  */
		  
		}/* if ((vert_swap != -2) && (stat[vert_swap] == 1) &&... */
	      
	      if (i_swap == (num_candC-1)) i_swap = -1;
	      parada_2--;
	      
	    }/* for (parada_2=num_candC, i_swap=(int)(rand() ...*/
	  
	  testa_A = true;
	  vez     = 0;
	}/* if ((vez == 1) && (!moveu) && (!testa_A)) */
      


      /* -----------> 2 NIVEL) C -> B */
      if ((vez == 0) && (!moveu) && (!testa_B))
	{
	  for (parada_2=num_candC, i_swap=(int)(rand() % num_candC); parada_2 > 0 && (moveu==false); i_swap++)
	    {
	      vert_swap    = c[i_swap];

	      if ((vert_swap != -2) && (stat[vert_swap] == 1) && (C[vert_swap] == 1) && ((desceu1 != vert_swap) || (origem1 != 1)) && ((desceu2 != vert_swap) || (origem2 != 1)))
		{
		  e_cand = can_move_C_X_v2(vert_swap, b, a, C);
		  
		  if (e_cand)
		    {
		      if (DEPU) std::cout<<std::endl<<"  vert_CB = "<<vert_swap<<std::endl;
		      B[vert_swap]   = 1; 
		      C[vert_swap]   = 0;
		      c[i_swap]      = -2;
		      b[num_candB]   = vert_swap;
		      b[num_candB+1] = -1;
		    
		      /* 3 NIVEL) 2C -> A ou B */
		      for (parada_3=num_candC, l1=(int)(rand() % num_candC); parada_3 > 0 && (moveu==false); l1++)
			{
			  if ((c[l1] != -2) && (stat[c[l1]] == 1) && (C[c[l1]] == 1))
			    if (   (can_move_C_X_v2(c[l1], a, b, C))  ||  (can_move_C_X_v2(c[l1], b, a, C)  ))
			      for (parada_4=num_candC, l2=(int)(rand() % num_candC); parada_4 > 0 && (moveu==false); l2++)
				{
				  if ((c[l2] != -2) && (c[l1] < c[l2]) && (stat[c[l2]] == 1) && (C[c[l2]] == 1))
				    {
				      j = can_2move_C_AB_v2(l1, l2, num_candA, num_candB+1, a, b, C, c, TEST);
				      
				      if (j == 1)
					{
					  if (DEPU) std::cout<<std::endl<<"    vert_C_AA = "<<l1<<","<<l2<<" 2MOVEU !"<<std::endl;
					  A[c[l1]]  = 1; C[c[l1]]  = 0; A[c[l2]]  = 1; C[c[l2]]  = 0; 
					  atualiza_a_b_c(A, a, B, b, C, c); moveu = true;
					}
				      if (j == 2)
					{
					  if (DEPU) std::cout<<std::endl<<"    vert_C_AB = "<<l1<<","<<l2<<" 2MOVEU !"<<std::endl;
					  A[c[l1]]  = 1; C[c[l1]]  = 0; B[c[l2]]  = 1; C[c[l2]]  = 0; 
					  atualiza_a_b_c(A, a, B, b, C, c); moveu = true;
					}
				      if (j == 3)
					{
					  if (DEPU) std::cout<<std::endl<<"    vert_C_BA = "<<l1<<","<<l2<<" 2MOVEU !"<<std::endl;
					  B[c[l1]]  = 1; C[c[l1]]  = 0; A[c[l2]]  = 1; C[c[l2]]  = 0; 
					  atualiza_a_b_c(A, a, B, b, C, c); moveu = true;	
					}
				      if (j == 4)
					{
					  if (DEPU) std::cout<<std::endl<<"    vert_C_BB = "<<l1<<","<<l2<<" 2MOVEU !"<<std::endl;
					  B[c[l1]]  = 1; C[c[l1]]  = 0; B[c[l2]]  = 1; C[c[l2]]  = 0; 
					  atualiza_a_b_c(A, a, B, b, C, c); moveu = true;
					}
				    }/*if ((c[l2] != -2) && (c[l1] < c[l2]) && (stat[c[l2]] == 1) && (C[c[l2]] == 1)) */
				  
				  if (l2 == (num_candC-1)) l2 = -1;
				  parada_4--;
				}/* for (parada_4=num_candC, l2=(int)(rand() % num_candC); parada_4 > 0 && (moveu==false); l2++) */
			  
			  if (l1 == (num_candC-1)) l1 = -1;
			  parada_3--;
			}/* for (parada_3=num_candC, l1=(int)(rand() % num_candC); parada_3 > 0 && (moveu==false); l1++) */

		      if (!moveu)
			{
			  C[vert_swap] = 1;
			  B[vert_swap] = 0;
			  c[i_swap]    = vert_swap;
			  b[num_candB] = -1;
			  if (TEST) testa_particoes_grasp_sig_v2(A, a, B, b, C, c);
			}
		    }/* if (e_cand)  */
		  
		}/* if ((vert_swap != -2) && (stat[vert_swap] == 1) &&... */
	      
	      if (i_swap == (num_candC-1)) i_swap = -1;
	      parada_2--;

	    }/* for (parada_2=num_candC, i_swap=(int)(rand() ...*/
	  
	  testa_B = true;
	  vez     = 1;

	}/* if ((vez == 1) && (!moveu) && (!testa_B)) */

    }/* while ((!testa_A || !testa_B) && (!moveu)) */

  return moveu;
}








/* vizinhanca do GRASP para o problema do grafo de sinais -> desce um de A e sobem 2 para A ou B */
int Sigraph::viz_down_A_v2(Array<int> &A, Array<int> &a, Array<int> &B, Array<int> &b, Array<int> &C, Array<int> &c, Array<int> &cand1, Array<int> &cand2, int TEST, unsigned long int t_ini_g)
{
  int       num_candA, num_candC, vert_AC, i_AC, parada_1;
  bool      moveu=false;

  int       DEPU = 0;

  if (DEPU) std::cout<<std::endl<<"*************  viz_down_A  ****************** "<<std::endl;

  /* ----------------------------- conta numero de candidatos de A e C */
  for (num_candA=0; a[num_candA]!=-1; num_candA++);
  for (num_candC=0; c[num_candC]!=-1; num_candC++);

  if (num_candA == 0)
    return 0;

    /* 1 NIVEL) A -> C */
    for (vert_AC = -1, parada_1=num_candA, i_AC=(int)(rand() % num_candA); parada_1 > 0; i_AC++)
      {
	if (a[i_AC] != -2) 
	  {
	    vert_AC = a[i_AC];
	    if (DEPU) std::cout<<std::endl<<"vert_AC = "<<vert_AC<<std::endl;
	    
	    /* ---> */
	    A[vert_AC]     = 0;
	    C[vert_AC]     = 1;
	    a[i_AC]        = -2;
	    c[num_candC]   = vert_AC;
	    c[num_candC+1] = -1;

	    moveu = move_2_C_AB_v2(vert_AC, 0, A, a, B, b, C, c, cand1, cand2, TEST);

	    if (moveu==true) 
	      break;
	    else
	      {
		/* <--- */
		C[vert_AC]   = 0;
		A[vert_AC]   = 1;
		a[i_AC]      = vert_AC;
		c[num_candC] = -1;
	      }
	  }

	if (i_AC == (num_candA-1)) i_AC = -1;
	parada_1--;

      }

    if (TEST) testa_particoes_grasp_sig_v2(A, a, B, b, C, c);
    if (moveu)
      {
	/* maximiza solucao */
	maximiza_solucao_grasp_sig_v2(A, a, B, b, C, c, cand1, cand2, TEST);
	return 1;
      }
    else
      return 0;
}




/* vizinhanca do GRASP para o problema do grafo de sinais -> desce um de B e sobem 2 para A ou B */
int Sigraph::viz_down_B_v2(Array<int> &A, Array<int> &a, Array<int> &B, Array<int> &b, Array<int> &C, Array<int> &c, Array<int> &cand1, Array<int> &cand2, int TEST, unsigned long int t_ini_g)
{
  int       num_candB, num_candC, vert_BC, i_BC, parada_1;
  bool      moveu=false;

  int       DEPU = 0;

  if (DEPU) std::cout<<std::endl<<"*************  viz_down_B  ****************** "<<std::endl;

  /* ----------------------------- conta numero de candidatos de B e C */
  for (num_candB=0; b[num_candB]!=-1; num_candB++);
  for (num_candC=0; c[num_candC]!=-1; num_candC++);
 
  if (num_candB == 0)
    return 0;

    /* 1 NIVEL) B -> C */
    for (vert_BC = -1, parada_1=num_candB, i_BC=(int)(rand() % num_candB); parada_1 > 0; i_BC++)
      {
	if (b[i_BC] != -2) 
	  {
	    vert_BC = b[i_BC];
	    if (DEPU) std::cout<<std::endl<<"vert_BC = "<<vert_BC<<std::endl;
	    
	    /* ---> */
	    B[vert_BC]     = 0;
	    C[vert_BC]     = 1;
	    b[i_BC]        = -2;
	    c[num_candC]   = vert_BC;
	    c[num_candC+1] = -1;

	    moveu = move_2_C_AB_v2(vert_BC, 1, A, a, B, b, C, c, cand1, cand2, TEST);

	    if (moveu==true) 
	      break;
	    else
	      {
		/* <--- */
		C[vert_BC]   = 0;
		B[vert_BC]   = 1;
		b[i_BC]      = vert_BC;
		c[num_candC] = -1;
	      }
	  }

	if (i_BC == (num_candB-1)) i_BC = -1;
	parada_1--;

      }

    if (TEST) testa_particoes_grasp_sig_v2(A, a, B, b, C, c);
    if (moveu)
      {
	/* maximiza solucao */
	maximiza_solucao_grasp_sig_v2(A, a, B, b, C, c, cand1, cand2, TEST);
	return 1;
      }
    else
      return 0;
}



/* vizinhanca do GRASP para o problema do grafo de sinais -> desce 2 de A e sobem 3 para A ou B */
int Sigraph::viz_2down_A_v2(Array<int> &A, Array<int> &a, Array<int> &B, Array<int> &b, Array<int> &C, Array<int> &c, Array<int> &cand1, Array<int> &cand2, int TEST, unsigned long int t_ini_g)
{
  int       vert_AC1, vert_AC2, i_AC1, i_AC2, parada_1, parada_2, num_candA, num_candC;
  bool      moveu=false;

  int       DEPU = 0;

  if (DEPU) std::cout<<std::endl<<"*************  viz_2down_A_v2  ****************** "<<std::endl;

  /* ----------------------------- conta numero de candidatos de A e C */
  for (num_candA=0; a[num_candA]!=-1; num_candA++);
  for (num_candC=0; c[num_candC]!=-1; num_candC++);

  if (num_candA <= 1)
    return 0;

  /* 1 NIVEL) 1A -> C */
  for (vert_AC1 = -1, parada_1=num_candA, i_AC1=(int)(rand() % num_candA); parada_1 > 0; i_AC1++)
    {
      if (a[i_AC1] != -2) 
	{
	  vert_AC1 = a[i_AC1];
	  
	  /* ---> */
	  A[vert_AC1]    = 0;
	  C[vert_AC1]    = 1;
	  a[i_AC1]       = -2;
	  c[num_candC]   = vert_AC1;
	  c[num_candC+1] = -1;
	  
	  /* 1 NIVEL) 2A -> C */
	  for (vert_AC2 = -1, parada_2=num_candA, i_AC2=(int)(rand() % num_candA); parada_2 > 0; i_AC2++)
	    {
	      if ((a[i_AC2] != -2) && (a[i_AC2] > vert_AC1))
		{
		  vert_AC2 = a[i_AC2];
		  if (DEPU) std::cout<<std::endl<<"vert_AA_C = "<<vert_AC1<<","<<vert_AC2<<std::endl;
				  
	  	  /* ---> */
		  A[vert_AC2]    = 0;
		  C[vert_AC2]    = 1;
		  a[i_AC2]       = -2;
		  c[num_candC+1] = vert_AC2;
		  c[num_candC+2] = -1;

		  moveu = move_3_C_AB_v2(vert_AC1, vert_AC2, 0, 0, A, a, B, b, C, c, cand1, cand2, TEST);
		  
		  if (moveu==true) 
		    break;
		  else
		    {
		      /* <--- */
		      C[vert_AC2]    = 0;
		      A[vert_AC2]    = 1;
		      a[i_AC2]       = vert_AC2;
		      c[num_candC+1] = -1;
		    }

		  if (calcula_tempo(t_ini_g, (unsigned long int) clock()) > TEMPOMAXGRASP)
		    {
		      /* <--- */
		      C[vert_AC1]  = 0;
		      A[vert_AC1]  = 1;
		      a[i_AC1]     = vert_AC1;
		      c[num_candC] = -1;

		      return 0;
		    }

		}/* if ((a[i_AC2] != -2) && (a[i_AC2] > vert_AC1)) */

	      if (i_AC2 == (num_candA-1)) i_AC2 = -1;
	      parada_2--;

	    }/* for (vert_AC2 = -1, parada_2=num_candA, i_AC2=(int)(rand() % num_candA); parada_2 > 0; i_AC2++) */

	  if (moveu==true) 
	    break;
	  else
	    {
	      /* <--- */
	      C[vert_AC1]  = 0;
	      A[vert_AC1]  = 1;
	      a[i_AC1]     = vert_AC1;
	      c[num_candC] = -1;
	    }

	}/* if (a[i_AC1] != -2) */
      
      if (i_AC1 == (num_candA-1)) i_AC1 = -1;
      parada_1--;

    }/* for (vert_AC1 = -1, parada_1=num_candA, i_AC1=(int)(rand() % num_candA); parada_1 > 0; i_AC1++) */

  if (TEST) testa_particoes_grasp_sig_v2(A, a, B, b, C, c);
    if (moveu)
      {
	/* maximiza solucao */
	maximiza_solucao_grasp_sig_v2(A, a, B, b, C, c, cand1, cand2, TEST);
	return 1;
      }
    else
      return 0;
}



/* vizinhanca do GRASP para o problema do grafo de sinais -> desce 2 de B e sobem 3 para A ou B */
int Sigraph::viz_2down_B_v2(Array<int> &A, Array<int> &a, Array<int> &B, Array<int> &b, Array<int> &C, Array<int> &c, Array<int> &cand1, Array<int> &cand2, int TEST, unsigned long int t_ini_g)
{
  int       vert_BC1, vert_BC2, i_BC1, i_BC2, parada_1, parada_2, num_candB, num_candC;
  bool      moveu=false;

  int       DEPU = 0;

  if (DEPU) std::cout<<std::endl<<"*************  viz_2down_B_v2  ****************** "<<std::endl;

  /* ----------------------------- conta numero de candidatos de B e C */
  for (num_candB=0; b[num_candB]!=-1; num_candB++);
  for (num_candC=0; c[num_candC]!=-1; num_candC++);

  if (num_candB <= 1)
    return 0;

  /* 1 NIVEL) 1B -> C */
  for (vert_BC1 = -1, parada_1=num_candB, i_BC1=(int)(rand() % num_candB); parada_1 > 0; i_BC1++)
    {
      if (b[i_BC1] != -2) 
	{
	  vert_BC1 = b[i_BC1];
	  
	  /* ---> */
	  B[vert_BC1]    = 0;
	  C[vert_BC1]    = 1;
	  b[i_BC1]       = -2;
	  c[num_candC]   = vert_BC1;
	  c[num_candC+1] = -1;
	  
	  /* 1 NIVEL) 2B -> C */
	  for (vert_BC2 = -1, parada_2=num_candB, i_BC2=(int)(rand() % num_candB); parada_2 > 0; i_BC2++)
	    {
	      if ((b[i_BC2] != -2) && (b[i_BC2] > vert_BC1))
		{
		  vert_BC2 = b[i_BC2];
		  if (DEPU) std::cout<<std::endl<<"vert_BB_C = "<<vert_BC1<<","<<vert_BC2<<std::endl;
				  
	  	  /* ---> */
		  B[vert_BC2]    = 0;
		  C[vert_BC2]    = 1;
		  b[i_BC2]       = -2;
		  c[num_candC+1] = vert_BC2;
		  c[num_candC+2] = -1;

		  moveu = move_3_C_AB_v2(vert_BC1, vert_BC2, 1, 1, A, a, B, b, C, c, cand1, cand2, TEST);
		  
		  if (moveu==true) 
		    break;
		  else
		    {
		      /* <--- */
		      C[vert_BC2]    = 0;
		      B[vert_BC2]    = 1;
		      b[i_BC2]       = vert_BC2;
		      c[num_candC+1] = -1;
		    }

		   if (calcula_tempo(t_ini_g, (unsigned long int) clock()) > TEMPOMAXGRASP)
		    {
		      /* <--- */
		      C[vert_BC1]  = 0;
		      B[vert_BC1]  = 1;
		      b[i_BC1]     = vert_BC1;
		      c[num_candC] = -1;

		      return 0;
		    }

		}/* if ((b[i_BC2] != -2) && (b[i_BC2] > vert_BC1)) */

	      if (i_BC2 == (num_candB-1)) i_BC2 = -1;
	      parada_2--;

	    }/* for (vert_BC2 = -1, parada_2=num_candB, i_BC2=(int)(rand() % num_candB); parada_2 > 0; i_BC2++) */

	  if (moveu==true) 
	    break;
	  else
	    {
	      /* <--- */
	      C[vert_BC1]  = 0;
	      B[vert_BC1]  = 1;
	      b[i_BC1]     = vert_BC1;
	      c[num_candC] = -1;
	    }

	}/* if (b[i_BC1] != -2) */
      
      if (i_BC1 == (num_candB-1)) i_BC1 = -1;
      parada_1--;

    }/* for (vert_BC1 = -1, parada_1=num_candB, i_BC1=(int)(rand() % num_candB); parada_1 > 0; i_BC1++) */

  if (TEST) testa_particoes_grasp_sig_v2(A, a, B, b, C, c);
    if (moveu)
      {
	/* maximiza solucao */
	maximiza_solucao_grasp_sig_v2(A, a, B, b, C, c, cand1, cand2, TEST);
	return 1;
      }
    else
      return 0;
}



/* vizinhanca do GRASP para o problema do grafo de sinais -> desce 2 de AB (1 de A e um de B )e sobem 3 para A ou B */
int Sigraph::viz_2down_AB_v2(Array<int> &A, Array<int> &a, Array<int> &B, Array<int> &b, Array<int> &C, Array<int> &c, Array<int> &cand1, Array<int> &cand2, int TEST, unsigned long int t_ini_g)
{
  int       vert_AC1, vert_BC1, i_AC1, i_BC1, parada_1, parada_2, num_candA, num_candB, num_candC;
  bool      moveu=false;

  int       DEPU = 0;

  if (DEPU) std::cout<<std::endl<<"*************  viz_2down_AB_v2  ****************** "<<std::endl;

  /* ----------------------------- conta numero de candidatos de A, B e C */
  for (num_candA=0; a[num_candA]!=-1; num_candA++);
  for (num_candB=0; b[num_candB]!=-1; num_candB++);
  for (num_candC=0; c[num_candC]!=-1; num_candC++);

  if ((num_candB == 0) || (num_candA == 0))
    return 0;

  /* 1 NIVEL) 1A -> C */
  for (vert_AC1 = -1, parada_1=num_candA, i_AC1=(int)(rand() % num_candA); parada_1 > 0; i_AC1++)
    {
      if (a[i_AC1] != -2) 
	{
	  vert_AC1 = a[i_AC1];
	  
	  /* ---> */
	  A[vert_AC1]    = 0;
	  C[vert_AC1]    = 1;
	  a[i_AC1]       = -2;
	  c[num_candC]   = vert_AC1;
	  c[num_candC+1] = -1;
	  
	  /* 1 NIVEL) 2B -> C */
	  for (vert_BC1 = -1, parada_2=num_candB, i_BC1=(int)(rand() % num_candB); parada_2 > 0; i_BC1++)
	    {
	      if (b[i_BC1] != -2) 
		{
		  vert_BC1 = b[i_BC1];
		  if (DEPU) std::cout<<std::endl<<"vert_AB_C = "<<vert_AC1<<","<<vert_BC1<<std::endl;
				  
	  	  /* ---> */
		  B[vert_BC1]    = 0;
		  C[vert_BC1]    = 1;
		  b[i_BC1]       = -2;
		  c[num_candC+1] = vert_BC1;
		  c[num_candC+2] = -1;

		  moveu = move_3_C_AB_v2(vert_AC1, vert_BC1, 0, 1, A, a, B, b, C, c, cand1, cand2, TEST);
		  
		  if (moveu==true) 
		    break;
		  else
		    {
		      /* <--- */
		      C[vert_BC1]    = 0;
		      B[vert_BC1]    = 1;
		      b[i_BC1]       = vert_BC1;
		      c[num_candC+1] = -1;
		    }

		  if (calcula_tempo(t_ini_g, (unsigned long int) clock()) > TEMPOMAXGRASP)
		    {
		      /* <--- */
		      C[vert_AC1]  = 0;
		      A[vert_AC1]  = 1;
		      a[i_AC1]     = vert_AC1;
		      c[num_candC] = -1;
		      
		      return 0;
		    }

		}/* if (b[i_BC1] != -2) */

	      if (i_BC1 == (num_candB-1)) i_BC1 = -1;
	      parada_2--;

	    }/* for (vert_BC1 = -1, parada_2=num_candB, i_BC1=(int)(rand() % num_candB); parada_2 > 0; i_BC1++) */

	  if (moveu==true) 
	    break;
	  else
	    {
	      /* <--- */
	      C[vert_AC1]  = 0;
	      A[vert_AC1]  = 1;
	      a[i_AC1]     = vert_AC1;
	      c[num_candC] = -1;
	    }

	}/* if (a[i_AC1] != -2) */
      
      if (i_AC1 == (num_candA-1)) i_AC1 = -1;
      parada_1--;

    }/* for (vert_AC1 = -1, parada_1=num_candA, i_AC1=(int)(rand() % num_candA); parada_1 > 0; i_AC1++) */

  if (TEST) testa_particoes_grasp_sig_v2(A, a, B, b, C, c);
    if (moveu)
      {
	/* maximiza solucao */
	maximiza_solucao_grasp_sig_v2(A, a, B, b, C, c, cand1, cand2, TEST);
	return 1;
      }
    else
      return 0;
}



/* funcao objetivo do GRASP para o problema do grafo de sinais */
int Sigraph::obj_grasp_sig_v2(Array<int> &A, Array<int> &B)
{
  int i,obj=0;

  for (i=0; i<n; i++)
    if (A[i] == 1)
      obj++;

  for (i=0; i<n; i++)
    if (B[i] == 1)
      obj++;

  return obj;
}

/* calculo do tempo */
double Sigraph::calcula_tempo(const unsigned long int ini, const unsigned long int fim)
{
  double r;

  if(fim >= ini)
    r = ((double)(fim - ini)) / CLOCKS_PER_SEC;
  else
    r = ((double)( (fim + (unsigned long int)-1) - ini)) / CLOCKS_PER_SEC;
  return r;
}



/* GRASP para o problema do grafo de sinais */
int Sigraph::grasp_sig_v2(Array<int> &A, Array<int> &a, Array<int> &B, Array<int> &b, Array<int> &C, Array<int> &c, Array<int> &cand1, Array<int> &cand2, Array<int> &b_A, Array<int> &b_B, int ITMAX, int TEST)
{
  int          it,sol,b_sol=-1, vez, ii;
  bool         moveu, viz_A, viz_B, viz_AB;
  unsigned long int t_ini_g;

  /* PARAMETROS */
  int          DEPU=0;
  //int          MAXTIME  = TEMPOMAXGRASP; /* 5 min */

  t_ini_g  = (unsigned long int) clock();

  for (it=0; it<ITMAX; it++)
    {
      sol = metodo_construtivo_grasp_sig_v2(A, a, B, b, C, c, cand1, cand2, TEST);
      if (DEPU) std::cout<<std::endl<<"IT = "<<it<<") solucao inicial com "<<sol<<" vertices"<<std::endl;

      moveu = true;
      while (moveu)
      	{
      	  moveu = false;

	  // ---------> 1-swap
	  viz_A = false;
	  viz_B = false;
	  vez   = (int)(rand() % 2);
	  while ((!viz_A) || (!viz_B))
	    {
	      if ((vez == 1) && (!viz_A))
		{
		  if (viz_down_A_v2(A, a, B, b, C, c, cand1, cand2, TEST, t_ini_g) == 1)
		    {
		      if (DEPU) std::cout<<"MOVEU -> viz_down_A_v2"<<std::endl;
		      moveu = true;
		      break;
		    }

		  vez   = 0;
		  viz_A = true;
		}

	      /* teste de parada por tempo */
	      if (calcula_tempo(t_ini_g, (unsigned long int) clock()) > TEMPOMAXGRASP)
		break;
	      
	      if ((vez == 0)&& (!viz_B))
		{
		  if (viz_down_B_v2(A, a, B, b, C, c, cand1, cand2, TEST, t_ini_g) == 1)
		    {
		      if (DEPU) std::cout<<"MOVEU -> viz_down_B_v2"<<std::endl;
		      moveu = true;
		      break;
		    }

		  vez = 1;
		  viz_B = true;
		}

	      /* teste de parada por tempo */
	      if (calcula_tempo(t_ini_g, (unsigned long int) clock()) > TEMPOMAXGRASP)
		break;
	    }

	  /* teste de parada por tempo */
	  if (calcula_tempo(t_ini_g, (unsigned long int) clock()) > TEMPOMAXGRASP)
	    break;

	  // ---------> 2-swap
	  if (!moveu)
	    {
	      viz_A  = false;
	      viz_B  = false;
	      viz_AB = false;
	      vez    = (int)(rand() % 3);
	      
	      while ((!viz_A) || (!viz_B) || (!viz_AB))
		{
		  if ((vez == 0) && (!viz_A))
		    {
		      if (viz_2down_A_v2(A, a, B, b, C, c, cand1, cand2, TEST, t_ini_g) == 1)
			{
			  if (DEPU) std::cout<<"MOVEU -> viz_2down_A_v2"<<std::endl;
			  moveu = true;
			  break;
			}
		      
		      vez   = 1;
		      viz_A = true;
		    }

		  /* teste de parada por tempo */
		  if (calcula_tempo(t_ini_g, (unsigned long int) clock()) > TEMPOMAXGRASP)
		    break;
	      
		  if ((vez == 1) && (!viz_B))
		    {
		      if (viz_2down_B_v2(A, a, B, b, C, c, cand1, cand2, TEST, t_ini_g) == 1)
			{
			  if (DEPU) std::cout<<"MOVEU -> viz_2down_B_v2"<<std::endl;
			  moveu = true;
			  break;
			}

		      vez = 2;
		      viz_B = true;
		    }

		  /* teste de parada por tempo */
		  if (calcula_tempo(t_ini_g, (unsigned long int) clock()) > TEMPOMAXGRASP)
		    break;
		  
		  if ((vez == 2) && (!viz_AB))
		    {
		      if (viz_2down_AB_v2(A, a, B, b, C, c, cand1, cand2, TEST, t_ini_g) == 1)
			{
			  if (DEPU) std::cout<<"MOVEU -> viz_2down_AB_v2"<<std::endl;
			  moveu = true;
			  break;
			}

		      vez = 0;
		      viz_AB = true;
		    }

		  /* teste de parada por tempo */
		  if (calcula_tempo(t_ini_g, (unsigned long int) clock()) > TEMPOMAXGRASP)
		    break;

		}/* while ((!viz_A) || (!viz_B) || (!viz_AB))*/
	    }/* if (!moveu) */

      	  if (moveu)
	    {
	      sol = obj_grasp_sig_v2(A, B);
	      if (TEST) testa_particoes_grasp_sig_v2(A, a, B, b, C, c);
	    }

	  /* teste de parada por tempo */
	  if (DEPU) std::cout<<std::endl<<"TEMPO = "<<calcula_tempo(t_ini_g, (unsigned long int) clock())<<" seg"<<std::endl;
	  if (calcula_tempo(t_ini_g, (unsigned long int) clock()) > TEMPOMAXGRASP)
	    break;
	}

      if (moveu)
	{
	  sol = obj_grasp_sig_v2(A, B);
	  if (TEST) testa_particoes_grasp_sig_v2(A, a, B, b, C, c);
	}
      
      if (sol > b_sol)
	{
	  b_sol   = sol;
	  if (DEPU) std::cout<<std::endl<<"IT = "<<it<<") ---------------------------------- MELHOR SOLUCAO COM "<<sol<<" VERTICES"<<std::endl;

	  for (ii=0; ii<n; ii++)
	    {
	      b_A[ii] = A[ii];
	      b_B[ii] = B[ii];
	    }
	}
      
      /* teste de parada por tempo */
      if (DEPU) std::cout<<std::endl<<"TEMPO = "<<calcula_tempo(t_ini_g, (unsigned long int) clock())<<" seg"<<std::endl;
      if (calcula_tempo(t_ini_g, (unsigned long int) clock()) > TEMPOMAXGRASP)
        break;

    } /* for (it=0; it<ITMAX; it++) */

  //if (DEPU) std::cout<<std::endl<<"bitibas ("<<it_best<<")\t";
  return b_sol;
}



/*-------------------------------------------------  TAD -------------------------------------------------- */

/* flag = 1 (deleta positiva) = 2 (deleta negativa) = 3 (as duas) */
void Sigraph::delete_edge(int i, int last_j, int flag)
{
  int    j, w;
  
  /* Corrige estrutura Gp */
  if ((g(i,last_j).pos) && ((flag == 1) || (flag == 3)))
    {
      /* -> */
      for (j=0; Gp(i,j)!=-1; ++j) 
	if (Gp(i,j) == last_j)
	  {
	    for (w=j; Gp(i,w)!=-1; ++w)
	      Gp(i,w) = Gp(i,w+1);
	    break;
	  }
      
      /* <- */
      for (j=0; Gp(last_j,j)!=-1; ++j) 
	if (Gp(last_j,j) == i)
	  {
	    for (w=j; Gp(last_j,w)!=-1; ++w)
	      Gp(last_j,w) = Gp(last_j,w+1);
	    break;
	  }
    }
  
  /* Corrige estrutura Gn */
  if ((g(i,last_j).neg) && ((flag == 2) || (flag == 3)))
    {
      for (j=0; Gn(i,j)!=-1; ++j) 
	if (Gn(i,j) == last_j)
	  {
	    for (w=j; Gn(i,w)!=-1; ++w)
	      Gn(i,w) = Gn(i,w+1);
	    break;
	  }
      
      /* <- */
      for (j=0; Gn(last_j,j)!=-1; ++j) 
	if (Gn(last_j,j) == i)
	  {
	    for (w=j; Gn(last_j,w)!=-1; ++w)
	      Gn(last_j,w) = Gn(last_j,w+1);
	    break;
	  }
    }
	    
  /* Corrige estrutura g */
  
  if ((flag == 1) || (flag == 3))
    {
      g(i,last_j).pos = false;
      g(last_j,i).pos = false;
    }

  if ((flag == 2) || (flag == 3))
    {
      g(i,last_j).neg = false;
      g(last_j,i).neg = false;
    }
  
}


/* flag = 1 (deleta positiva) = 2 (deleta negativa) = 3 (as duas) */
void Sigraph::delete_all_edge(int i, int flag)
{
  int j;

  if ((flag == 1) || (flag == 3))
    for (j=0; j<n; ++j)
      if (stat[j] == 1)
	if (g(i,j).pos == true)
	  delete_edge(i, j, flag);

  if ((flag == 2)|| (flag == 3))
    for (j=0; j<n; ++j)
      if (stat[j] == 1)
	if (g(i,j).neg == true)
	  delete_edge(i, j, flag);
}


/* flag = 1 (insere positiva) = 2 (insere negativa) = 3 (as duas) */
void Sigraph::insert_edge(int i, int last_j, int flag)
{
  int    j;
  
  /* Corrige estrutura Gp */
  if ((!g(i,last_j).pos) && ((flag == 1) || (flag == 3)))
    {
      /* -> */
      for (j=0; Gp(i,j)!=-1; ++j);
      Gp(i,j) = last_j;
      
      /* <- */
      for (j=0; Gp(last_j,j)!=-1; ++j);
      Gp(last_j,j) = i;
    }
  
  /* Corrige estrutura Gn */
  if ((!g(i,last_j).neg) && ((flag == 2) || (flag == 3)))
    {
      /* -> */
      for (j=0; Gn(i,j)!=-1; ++j);
      Gn(i,j) = last_j;

      /* <- */
      for (j=0; Gn(last_j,j)!=-1; ++j);
      Gn(last_j,j) = i;
    }
	    
  /* Corrige estrutura g */
  
  if ((flag == 1) || (flag == 3))
    {
      g(i,last_j).pos = true;
      g(last_j,i).pos = true;
    }

  if ((flag == 2) || (flag == 3))
    {
      g(i,last_j).neg = true;
      g(last_j,i).neg = true;
    }
  
}


// gera um arquivo .G a partir do grafo
void Sigraph::write(const char * name, int n_ori, int m_ori) 
{
  int            i,j,l,m,nn=0,ind_i=-1, ind_j=-1;
  std::ofstream  arq_out;
  char           name_G[256];
  Array<int>     mapa;

  // aloca
  mapa.aloca(n);

  /* abre arquivo de saida */
  strcpy (name_G,name);
  strcat (name_G,".g");
  std::cout<<std::endl<<name_G<<std::endl;
  arq_out.open(name_G);

  // conta o numero de vertices
  for (i=0; i<n; ++i)
    if (stat[i]==1)
      nn++;

  /* conta numero de arestas */
  for (m=0, i=0; i<n-1; i++)
    if (stat[i] == 1)
      for (j=i+1; j<n; j++)
	if ((stat[j] == 1) && (g(i,j).pos || g(i,j).neg))
	  m++;

  /* n e m */
  arq_out<<nn<<" "<<m<<std::endl;

  // gera mapeamento
  for (nn=0,i=0; i<n; ++i)
    if (stat[i]==1)
      {
	mapa[nn] = i;
	nn++;
      }

  /* escreve arestas */
  for (m=0, i=0; i<n-1; i++)
    if (stat[i] == 1)
      for (j=i+1; j<n; j++)
	if (stat[j] == 1) 
	  {
	    // mapa
	    if (g(i,j).pos || g(i,j).neg)
	      {
		for(ind_i=-1, l=0;l<nn;l++)
		  if (mapa[l]==i)
		    {
		      ind_i = l;
		      break;
		    }
		if (ind_i == -1) { std::cout<<"    ERRO ERRO ERRO write1"; abort();}

		for(ind_j=-1, l=0;l<nn;l++)
		  if (mapa[l]==j)
		    {
		      ind_j = l;
		      break;
		    }
		if (ind_j == -1) { std::cout<<"    ERRO ERRO ERRO write2"; abort();}

	      }

	    if (g(i,j).pos && g(i,j).neg)
	      arq_out<<ind_i<<" "<<ind_j<<" "<<"2"<<std::endl;
	    else
	      if (g(i,j).pos)
		arq_out<<ind_i<<" "<<ind_j<<" "<<"1"<<std::endl;
	      else
		if (g(i,j).neg)
		  arq_out<<ind_i<<" "<<ind_j<<" "<<"-1"<<std::endl;
	  }

  /* escreve os numeros de vertices e arestas originais */
  arq_out<<n_ori<<" "<<m_ori<<std::endl;

  /* fecha arquivo de saida */
  arq_out.close();

  // desaloca
  mapa.desaloca();
}


// gera um arquivo .G a partir do grafo
void Sigraph::write_sol(const char * name, Array<int> &A, Array<int> &B) 
{
  int            i;
  std::ofstream  arq_out;
  char           name_G[256];

  /* abre arquivo de saida */
  strcpy (name_G,name);
  strcat (name_G,".sol");
  arq_out.open(name_G);

  /* escreve vertices de A */
  for (i=0; i<n; i++)
    if (A[i] == 1)
      arq_out<<i<<std::endl;

  /* escreve vertices de A */
  for (i=0; i<n; i++)
    if (B[i] == 1)
      arq_out<<(-i)<<std::endl;

  /* fecha arquivo de saida */
  arq_out.close();
}
